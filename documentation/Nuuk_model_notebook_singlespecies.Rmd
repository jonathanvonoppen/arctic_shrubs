---
title: 'Nuuk Fjord: Drivers of shrub abundance - beta-binomial mixture  model, separated by species'
author: "Jonathan von Oppen"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    code_folding: hide
    df_print: paged
    toc: yes
    toc_float:
      collapsed: no
  html_document:
    df_print: paged
    toc: yes
editor_options: 
  chunk_output_type: inline
---

```{r}
rm(list = ls())
```


## Dependencies
Packages included:

* tidyverse - for convenient code flow, data wrangling and plotting
* rjags & R2jags - to link JAGS and R
* skimr - for data summary
* corrr - to output correlation matrices in dataframe format
* cowplot & patchwork - to combine plot panels
* Rmarkdown - to produce this neat little documentation
```{r setup, message = FALSE}
# load pacman package from the repository, if you do not already have it
if (!require('pacman')) install.packages('pacman', repos="https://cloud.r-project.org")
pacman::p_load(tidyverse, # set of packages for data manipulation, exploration and visualisation
               rjags,     # to link JAGS and R
               R2jags,    # to link JAGS and R
               skimr,     # for quick dataframe inspection
               corrr,     # output correlation matrices as data frame
               cowplot,   # combine plot panels
               patchwork, # -"-
               rmarkdown) # for R Markdown formatting
```

Functions used: 

* predictor x species cover plot grid function
* effect size plot function
```{r}
# cover plot grids ----
pred.plot.grid <- function(df){
  
  taxa <- df %>% pull(taxon) %>% unique() %>% as.character()
  
  for(taxon_nr in 1:length(taxa)){
    plot <- ggplot(data = df %>% filter(taxon == taxa[taxon_nr]), 
                   aes(y = cover, group = taxon)) +
      geom_point(aes(x = pred_value), colour = "darkgrey") +
      geom_smooth(aes(x = pred_value), method = "lm", colour = "darkgreen", se = TRUE, na.rm = TRUE) +
      geom_smooth(aes(x = pred_value), method = "lm", formula = y ~ poly(x, 2), colour = "darkorange", se = TRUE, na.rm = TRUE) +
      facet_wrap(~predictor, scales = "free", ncol = 4) +
      scale_y_continuous("relative no. pin hits per plot",
                         limits = c(0, max(df %>% 
                                             filter(taxon == taxa[taxon_nr]) %>% 
                                             pull(cover)))) +
      labs(x = "predictor value") +
      ggtitle(paste0(taxa[taxon_nr], " cover ~ predictors")) +
      theme_bw() +
      theme(legend.position = "none")
    print(plot)
  }
}

# effect size plots ----
# for cases with only 'significant' effects
model_plot_sig_function <- function(model_coeff_output, title_string, plot_width) {
  target_vars <- c("b.tempjja.x", "b.tempjja.x2",
                   "b.tempcont.x", "b.tempcont.x2",
                   "b.precipjja.x", "b.precipjja.x2",
                   "b.sri",
                   "b.tri",
                   "b.tcws", 
                   "b.shrub_cov",
                   "b.gramin_cov",
                   "b.compet")
  solutions <- model_coeff_output
  names(solutions) <- c("variable", "post.mean", "post.sd", "l95", "l90", "u90", "u95", "Rhat")
  solutions <- solutions %>% 
    filter(variable %in% target_vars)
  # solutions$variable <- factor(solutions$variable,
  #                               levels = c("b.tempjja.x", "b.tempjja.x2",
  #                                          "b.tempcont.x", "b.tempcont.x2",
  #                                          "b.precipjja.x", "b.precipjja.x2",
  #                                          "b.sri",
  #                                          "b.tri",
  #                                          "b.twi",
  #                                          "b.compet"))
  min_value <- floor(min(solutions$l95))
  max_value <- ceiling(max(solutions$u95))
  solutions$sig <- "ns"
  solutions$sig[solutions$l95 < 0 & solutions$u95 < 0] <- "sig"
  solutions$sig[solutions$l95 > 0 & solutions$u95 > 0] <- "sig"
  label_colour <- rep("black", nrow(solutions))
  label_colour[solutions$sig == "sig"] <- theme_darkgreen
  label_face <- rep("plain", nrow(solutions))
  label_face[solutions$sig == "sig"] <- "bold"
  # label_face[response == "T1_mean" & solutions$sig == "sig"] <- "bold"
  title_string <- title_string
  title_colour <- "grey10"
  # if(response == "T1_mean" | response == "T1_amp") title_colour <- theme_red
  # if(response == "T2_mean" | response == "T2_amp") title_colour <- theme_yellow
  # if(response == "T1_mean") response <- "Soil"
  # if(response == "T2_mean") response <- "Ground"
  
  
  model_plot_sig <- ggplot(solutions, aes(x = variable, y = post.mean,
                                      ymin = l95, ymax = u95,
                                      colour = sig)) +
    geom_point() +
    geom_errorbar(width = .8) +
    theme_cowplot(18) +
    ylab("Effect Size (scaled)") +
    xlab("") +
    ggtitle(paste0(title_string)) +
    scale_colour_manual(values = c("black", theme_darkgreen)) +
    scale_y_continuous(limits = c(min_value, max_value), breaks = seq(min_value,max_value,0.5)) +
    # scale_x_discrete(limits = c("b.tempjja.x", "b.tempjja.x2",
    #         "b.tempcont.x", "b.tempcont.x2",
    #         "b.precipjja.x", "b.precipjja.x2",
    #         "b.sri",
    #         "b.tri",
    #         "b.twi",
    #         "b.compet"),
    #                  labels = c("summer temperature", bquote(.("summer") *" "* temperature^2),
    #                             "temperature variability", bquote(.("temperature") *" "* variability^2),
    #                             "summer precipitation", bquote(.("summer") *" "* precipitation^2),
    #                             "solar radiation",
  #                             "terrain ruggedness",
  #                             "moisture availability",
  #                             "competition")) +
  annotate("segment", x = 0, xend = plot_width, y = 0, yend = 0) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = label_colour, face = label_face),
          plot.title = element_text(colour = title_colour, face = "italic"),
          legend.position = "none")
  return(model_plot_sig)
}

# for cases with marginal 'significance'
model_plot_marg_function <- function(model_coeff_output, title_string, plot_width) {
  target_vars <- c("b.tempjja.x", "b.tempjja.x2",
                   "b.tempcont.x", "b.tempcont.x2",
                   "b.precipjja.x", "b.precipjja.x2",
                   "b.sri",
                   "b.tri",
                   "b.tcws", 
                   "b.shrub_cov",
                   "b.gramin_cov",
                   "b.compet")
  solutions <- model_coeff_output
  names(solutions) <- c("variable", "post.mean", "post.sd", "l95", "l90", "u90", "u95", "Rhat")
  solutions <- solutions %>% 
    filter(variable %in% target_vars)
  # solutions$variable <- factor(solutions$variable,
  #                               levels = c("b.tempjja.x", "b.tempjja.x2",
  #                                          "b.tempcont.x", "b.tempcont.x2",
  #                                          "b.precipjja.x", "b.precipjja.x2",
  #                                          "b.sri",
  #                                          "b.tri",
  #                                          "b.twi",
  #                                          "b.compet"))
  min_value <- floor(min(solutions$l95))
  max_value <- ceiling(max(solutions$u95))
  solutions$sig <- "ns"
  solutions$sig[solutions$l95 < 0 & solutions$u95 < 0] <- "sig"
  solutions$sig[solutions$l95 > 0 & solutions$u95 > 0] <- "sig"
  solutions$sig[solutions$l90 < 0 & solutions$u90 < 0 & solutions$l95 < 0 & solutions$u95 > 0] <- "marg"
  solutions$sig[solutions$l90 > 0 & solutions$u90 > 0 & solutions$l95 < 0 & solutions$u95 > 0] <- "marg"
  label_colour <- rep("black", nrow(solutions))
  label_colour[solutions$sig == "sig"] <- theme_darkgreen
  label_colour[solutions$sig == "marg"] <- theme_purple
  label_face <- rep("plain", nrow(solutions))
  label_face[solutions$sig == "sig"] <- "bold"
  # label_face[response == "T1_mean" & solutions$sig == "sig"] <- "bold"
  title_string <- title_string
  title_colour <- "grey10"
  # if(response == "T1_mean" | response == "T1_amp") title_colour <- theme_red
  # if(response == "T2_mean" | response == "T2_amp") title_colour <- theme_yellow
  # if(response == "T1_mean") response <- "Soil"
  # if(response == "T2_mean") response <- "Ground"
  
  
  model_plot_marg <- ggplot(solutions, aes(x = variable, y = post.mean,
                                      ymin = l95, ymax = u95,
                                      colour = sig)) +
    geom_point() +
    geom_errorbar(width = .8) +
    theme_cowplot(18) +
    ylab("Effect Size (scaled)") +
    xlab("") +
    ggtitle(paste0(title_string)) + 
    scale_colour_manual(values = c(theme_purple, "black", theme_darkgreen)) +
    scale_y_continuous(limits = c(min_value, max_value), breaks = seq(min_value,max_value,0.5)) +
    # scale_x_discrete(limits = c("b.tempjja.x", "b.tempjja.x2",
    #         "b.tempcont.x", "b.tempcont.x2",
    #         "b.precipjja.x", "b.precipjja.x2",
    #         "b.sri",
    #         "b.tri",
    #         "b.twi",
    #         "b.compet"),
    #                  labels = c("summer temperature", bquote(.("summer") *" "* temperature^2),
    #                             "temperature variability", bquote(.("temperature") *" "* variability^2),
    #                             "summer precipitation", bquote(.("summer") *" "* precipitation^2),
    #                             "solar radiation",
  #                             "terrain ruggedness",
  #                             "moisture availability",
  #                             "competition")) +
  annotate("segment", x = 0, xend = plot_width, y = 0, yend = 0) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = label_colour, face = label_face),
          plot.title = element_text(colour = title_colour, face = "italic"),
          legend.position = "none")
  return(model_plot_marg)
}

```

Colour scheme:
```{r}
# Colour scheme ####
theme_red <- "#E64447FF"
theme_blue <- "#12435DFF"
theme_lightblue <- "#1FA3AEFF"
theme_grey <- "#EDEDEDFF"
theme_yellow <- "#EEBE5BFF"

# additional colours
theme_darkblue <- "#1D5799"
theme_darkgreen <- "#13944D"
theme_orange <- "#B56A24"
theme_purple <- "#8757B3"
```

## Single-species models

This dataset is a new one containing predictors extracted from downscaled CHELSA climate data.

Analyses conducted on fusion table at **plot $\times$ taxon level** (as we are explicitly interested in plot-level variation of predictors, esp. slope, solar radiation, terrain ruggedness, topographical wetness, and competition): 3726 observations for 38 variables

```{r}
env_cov_bio <- read.csv("../data/nuuk_env_cover_plots.csv", header = T) %>% 
  # rename variable "twi_90m" to "twi"
  rename(twi = twi_90m)
```
<!-- <button class="btn btn-primary" data-toggle="collapse" data-target="#BlockName"> Show/Hide Data Summary </button> -->
<!-- <div id="BlockName" class="collapse"> -->
<!-- ```{r} -->
<!-- skim(env_cov_bio) -->
<!-- ``` -->


### Prepare data for JAGS model 
### a) selection of variables relevant for analysis
including predictors

* Information on site, plot, plot group, sampling location (lat, lon, altitude), sampling year 
* downscaled CHELSA predictors, averaged over a 30-year period (*[...]_ts_30*) 
* solar radiation index (SRI, following [Keating et al. 2007](http://www.bioone.org/doi/abs/10.2193/2006-359)), slope (erosion measure), Terrain Ruggedness Index (TRI, following [Riley et al. 1999](http://download.osgeo.org/qgis/doc/reference-docs/Terrain_Ruggedness_Index.pdf)), Normalised Difference Wetness Index (NDWI, [Gao 1996](https://www.sciencedirect.com/science/article/pii/S0034425796000673)), Tasseled Cap Wetness Index (TCWI, [Crist & Ciccone 1984](https://ieeexplore.ieee.org/document/4157507)), SAGA Topographic Wetness Index (TWI, see [Conrad et al. 2015](https://gmd.copernicus.org/articles/8/1991/2015/) and the [index documentation](http://www.saga-gis.org/saga_tool_doc/2.2.2/ta_hydrology_15.html))
* taxon (see above for levels)
* competition pressure in the community (as summed abundance of taller-growing shrub species within a plot, averaged within plot groups)

and response variable 

* cover (as relative no. hits per plot for each species)
```{r}
env_cov_bio_sub <- env_cov_bio %>% 
  select(site_alt_plotgroup_id, plot, site, site_alt_id, year, long, lat, alt,  # plot info / metadata
  ends_with("_ts_30"),        # CHELSA predictors averaged over 30-year period prior to study year
  inclin_down, sri, tcws, tri,# environmental data
  ends_with("_cover"), compet,# biotic predictors: shrub & cover, competition pressure
  taxon, cover)               # taxon, cover response
head(env_cov_bio_sub)
```

Let's check for correlation between the different moisture predictors and terrain ruggedness:

```{r}
(cor_moist <- env_cov_bio %>% 
  select(twi, ndwi, tcws, tri)) %>% 
  correlate(diagonal = 1)
```
$\Rightarrow$ NDWI and TCWS are highly correlated, but both are largely independent from TWI and TRI.
We'll go with TCWS for now, as it is perhaps the most evidence-based moisture predictor (TWI on the other hand should be least confounded by vegetation, but is also rather theoretical).

<br>

Predictors don't always vary between plots within plotgroups - perhaps due to several falling into the same CHELSA grid cell.

Example: plots within site 1, altitude 20, plot group 1: plot P146 is slightly off and therefore has different climate variables than the other ones

```{r}
env_cov_bio %>% filter(taxon == "Betula nana" & site_alt_plotgroup_id == "1_20_1") %>% 
  ggplot(aes(x = long, y = lat)) + 
  geom_point() + 
  geom_text(aes(label = plot), hjust = 0.0001) + 
  xlim(c(-51.78675, -51.7863))
env_cov_bio %>% filter(taxon == "Betula nana" & site_alt_plotgroup_id == "1_20_1") %>% 
  select(site_alt_plotgroup_id, plot, tempjja_ts_30)
```

Check for correlation between predictors:

```{r}
predictors_set <- env_cov_bio_sub %>% 
  select(ends_with("_ts_30"),   # CHELSA predictors averaged over 10-year period prior to study year
         inclin_down, sri, tri, tcws,      # environmental data
         shrub_cover, graminoid_cover, compet) %>%  # biotic predictors
  names()
# create basic correlation matrix
(cor_mat <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set) %>% 
  correlate(diagonal = 1) %>% 
  # drop all values < .4 to increase readability
  mutate_if(is.numeric, ~ ifelse(abs(.) < .4, NA, .)))
```

$\Rightarrow$ Maximum temperature is highly correlated with JJA temperature, minimum temperature with continentality, slope (inclin_down) with solar radiation, and spring precipitation variables with JJA precipitation.
Let's exclude them step by step and check the variance inflation factors (VIF) along the way. VIF values > 5 indicate collinearity issues.

```{r}
# for the whole set of predictors
(vif_predictors_1 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set) %>% 
  usdm::vif()) #%>% View()
# => drop tempmax (correlated w/ tempjja)
(vif_predictors_2 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30) %>% 
  usdm::vif()) #%>% View()
# => drop tempmin (correlated w/ tempcont)
(vif_predictors_3 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30,
                -tempmin_ts_30) %>% 
  usdm::vif()) #%>% View()
# => drop precipjfmam (correlated w/ precipjja & tempcont)
(vif_predictors_4 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30,
                -tempmin_ts_30,
                -contains("jfm")) %>% 
  usdm::vif()) #%>% View()
# => drop inclin_down (correlated w/ SRI)
(vif_predictors_5 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30,
                -tempmin_ts_30,
                -inclin_down,
                -contains("jfm")) %>% 
  usdm::vif()) #%>% View()
# => drop precipmam (correlated w/ precipjja)
(vif_predictors_6 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30,
                -tempmin_ts_30,
                -inclin_down,
                -contains("mam")) %>% 
  usdm::vif()) #%>% View()
```

All VIF are now < 3.1 -> OK! We can now exclude the dropped variables to obtain the final dataset. In addition, we rename the climate variables and delete the extension:

```{r}
env_cov_bio_sub <- env_cov_bio_sub %>% 
  dplyr::select(-tempmax_ts_30,
                -tempmin_ts_30,
                -inclin_down,
                -contains("mam")) %>% 
  
  rename(tempjja = tempjja_ts_30,
         tempcont = tempcont_ts_30,
         precipjja = precipjja_ts_30)
```

### b) raw data plots

### > species abundance along the gradient
```{r}
(nuuk_spec_abundance_plot <- ggplot(env_cov_bio %>% 
         
         # make site a factor
         mutate(site = as.factor(site)) %>% 
         mutate(site_alt_id = factor(site_alt_id, levels = c(paste(rep(1, 3), c("20", "100", "200"), sep = "_"),
                                                             paste(rep(2, 3), c("20", "100", "200"), sep = "_"),
                                                             paste(rep(3, 5), c("20", "100", "200", "300", "400"), sep = "_"),
                                                             paste(rep(4, 6), c("20", "100", "200", "300", "400", "500"), sep = "_"),
                                                             paste(rep(5, 6), c("20", "100", "200", "300", "400", "500"), sep = "_")))) %>% 
         # group by site and isocline
         group_by(site, site_alt_id), 
       
       aes(x = site_alt_id, 
           y = cover, 
           fill = site)) + 
  
  # draw boxplots of cover
  geom_boxplot() + 
  
  # split by taxon
  facet_grid(rows = vars(taxon)) +
  
  # scale_fill_manual() +
  theme_bw() +
  xlab("site / isocline") +
  theme(strip.text.y = element_text(face = "italic"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = rel(1.2)),
        axis.title = element_text(size = rel(1.2))))

# save plot
# save_plot(file.path("..", "figures", "nuuk_shrub_drivers_species_abundance_gradient.eps"),
#           nuuk_spec_abundance_plot, base_height = 18, base_aspect_ratio = 0.8)
```

### > predictor patterns along the gradient
```{r}
# data compilation ----
predictors_set <- env_cov_bio %>% 
  select(ends_with("_ts_30"),   # CHELSA predictors averaged over 10-year period prior to study year
         inclin_down, sri, tri, twi, tcws,      # environmental data
         compet) %>% 
  names()

preds_plot_data <- env_cov_bio %>% 
         
         # convert site, isocline & plotgroup to factors
         mutate(site = as.factor(site)) %>% 
         mutate(site_alt_id = factor(site_alt_id, levels = c(paste(rep(1, 3), c("20", "100", "200"), sep = "_"),
                                                             paste(rep(2, 3), c("20", "100", "200"), sep = "_"),
                                                             paste(rep(3, 5), c("20", "100", "200", "300", "400"), sep = "_"),
                                                             paste(rep(4, 6), c("20", "100", "200", "300", "400", "500"), sep = "_"),
                                                             paste(rep(5, 6), c("20", "100", "200", "300", "400", "500"), sep = "_")))) %>% 
         mutate(plotgroup = as.factor(plotgroup)) %>% 
           
         select(site, site_alt_id, predictors_set) %>% 
         
         # pivot to long format
         pivot_longer(cols = predictors_set,
                      names_to = "predictor",
                      values_to = "value") %>% 
           
         # convert predictor col to factor
         mutate(predictor = as.factor(predictor)) %>% 
        
         # rename predictors
         mutate(predictor = fct_recode(predictor,
                                       "summer \n temperature [°C]" = "tempjja_ts_30",
                                       "yearly maximum \n temperature [°C]" = "tempmax_ts_30",
                                       "yearly minimum \n temperature [°C]" = "tempmin_ts_30",
                                       "annual temperature \n variability [°C]" = "tempcont_ts_30",
                                       "cumulative summer \n precipitation [mm]" = "precipjja",
                                       "cumulative winter-spring \n precipitation [mm]" = "precipjfmam_ts_30",
                                       "cumulative spring \n precipitation [mm]" = "precipmam_ts_30",
                                       "slope angle [°]" = "inclin_down",
                                       "Solar Radiation \n Index" = "sri",
                                       "Terrain Ruggedness \n Index" = "tri",
                                       "Topographic Wetness \n Index" = "twi",
                                       "Tasseled-cap Wetness \n Index" = "tcws",
                                       "shrub cover" = "shrub_cover",
                                       "graminoid cover" = "graminoid_cover",
                                       "overgrowing \n competition" = "compet"),
                predictor = fct_relevel(predictor,
                                        "summer \n temperature [°C]",
                                        "yearly maximum \n temperature [°C]",
                                        "yearly minimum \n temperature [°C]",
                                        "annual temperature \n variability [°C]",
                                        "cumulative summer \n precipitation [mm]",
                                        "cumulative winter-spring \n precipitation [mm]",
                                        "cumulative spring \n precipitation [mm]",
                                        "slope angle [°]",
                                        "Solar Radiation \n Index",
                                        "Terrain Ruggedness \n Index",
                                        "Topographic Wetness \n Index",
                                        "Tasseled-cap Wetness \n Index",
                                        "shrub cover",
                                        "graminoid cover",
                                        "overgrowing \n competition")) %>% 
           
         # group by site & isocline 
         group_by(site, site_alt_id)

# climatic predictors ----
predictors_set_clim_long <- c("summer \n temperature [°C]",
                           "yearly maximum \n temperature [°C]",
                           "yearly minimum \n temperature [°C]",
                           "annual temperature \n variability [°C]",
                           "cumulative summer \n precipitation [mm]",
                           "cumulative winter-spring \n precipitation [mm]",
                           "cumulative spring \n precipitation [mm]")

(nuuk_preds_clim_gradient_plot <- ggplot(preds_plot_data %>% 
                                           filter(predictor %in% predictors_set_clim_long),
       
       aes(x = site_alt_id, 
           y = value, 
           fill = site)) + 
  
  # draw boxplots of values
  geom_boxplot() + 
  
  # split by taxon
  facet_grid(rows = vars(predictor), scales = "free_y") +

  # scale_fill_manual() +
  theme_bw() +
  xlab("site / isocline") +
  theme(strip.text.y = element_text(face = "italic"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = rel(1.2)),
        axis.title = element_text(size = rel(1.2))))

# save plot
# save_plot(file.path("..", "figures", "nuuk_shrub_drivers_preds_clim_gradient.eps"),
#           nuuk_preds_clim_gradient_plot, base_height = 15, base_aspect_ratio = 0.8)

# environmental predictors ----
predictors_set_env_long <- c("slope angle [°]",
                           "Solar Radiation \n Index",
                           "Terrain Ruggedness \n Index",
                           "Topographic Wetness \n Index",
                           "Tasseled-cap Wetness \n Index",
                           "shrub cover",
                           "graminoid cover",
                           "overgrowing \n competition")

(nuuk_preds_env_gradient_plot <- ggplot(preds_plot_data %>% 
                                           filter(predictor %in% predictors_set_env_long),
       
       aes(x = site_alt_id, 
           y = value, 
           fill = site)) + 
  
  # draw boxplots of values
  geom_boxplot() + 
  
  # split by taxon
  facet_grid(rows = vars(predictor), scales = "free_y") +

  # scale_fill_manual() +
  theme_bw() +
  xlab("site / isocline") +
  theme(strip.text.y = element_text(face = "italic"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = rel(1.2)),
        axis.title = element_text(size = rel(1.2))))

# save plot
save_plot(file.path("..", "figures", "nuuk_shrub_drivers_preds_env_gradient_incl_tcws.eps"),
          nuuk_preds_env_gradient_plot, base_height = 15, base_aspect_ratio = 0.8)

# final set of predictors ----
predictors_set_final_long <- c("summer \n temperature [°C]",
                               "annual temperature \n variability [°C]",
                               "cumulative summer \n precipitation [mm]",
                               "Solar Radiation \n Index",
                               "Terrain Ruggedness \n Index",
                               "Tasseled-cap Wetness \n Index",
                               "shrub cover",
                               "graminoid cover",
                               "overgrowing \n competition")

(nuuk_preds_final_gradient_plot <- ggplot(preds_plot_data %>% 
                                           filter(predictor %in% predictors_set_final_long),
       
       aes(x = site_alt_id, 
           y = value, 
           fill = site)) + 
  
  # draw boxplots of values
  geom_boxplot() + 
  
  # split by taxon
  facet_grid(rows = vars(predictor), scales = "free_y") +

  # scale_fill_manual() +
  theme_bw() +
  xlab("site / isocline") +
  theme(strip.text.y = element_text(face = "italic"),
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = rel(1.2)),
        axis.title = element_text(size = rel(1.2))))

# save plot
# save_plot(file.path("..", "figures", "nuuk_shrub_drivers_preds_final_gradient.eps"),
#           nuuk_preds_final_gradient_plot, base_height = 15, base_aspect_ratio = 0.8)
```

<br>

### > cover vs. predictors per species

How do the trends in cover response look for each of the predictors? Plot panels below show linear (green) and quadratic (orange) trendlines derived from linear models (different than the Bayesian approach used for analysis! but anyway useful to catch trends):
```{r}
# Prepare data for panel plots for cover against predictors for each species
env_cov_bio.long <- env_cov_bio %>% 
  select(taxon,
         tempjja_ts_30,
         tempcont_ts_30,
         precipjja,
         sri,
         tcws,
         tri,
         shrub_cover,
         graminoid_cover,
         compet,
         cover) %>% 
  # pivot to long format
  pivot_longer(cols = c(tempjja_ts_30,
                        tempcont_ts_30,
                        precipjja,
                        sri,
                        tcws,
                        tri,
                        shrub_cover,
                        graminoid_cover,
                        compet),
               names_to = "predictor",
               values_to = "pred_value")

# run
pred.plot.grid(env_cov_bio.long)
```


### c) adjustion of data structure

Data was ordered by site/altitude/plotgroup and taxon
```{r}
env_cov_bio_sub <- env_cov_bio_sub[order(env_cov_bio_sub$site_alt_plotgroup_id, env_cov_bio_sub$taxon),]

```

As JAGS is only able to handle numeric input, all variables are assigned a numeric identifier:
```{r}
env_cov_bio_sub$plotgroup.NUM <- as.numeric(factor(env_cov_bio_sub$site_alt_plotgroup_id,
                                                   levels = unique(env_cov_bio_sub$site_alt_plotgroup_id)))
env_cov_bio_sub$plot.NUM <- as.numeric(factor(env_cov_bio_sub$plot,
                                              levels = unique(env_cov_bio_sub$plot)))
env_cov_bio_sub$site_alt.NUM <- as.numeric(factor(env_cov_bio_sub$site_alt_id,
                                              levels = unique(env_cov_bio_sub$site_alt_id)))
env_cov_bio_sub$site.NUM <- as.numeric(factor(env_cov_bio_sub$site, levels = unique(env_cov_bio_sub$site)))
env_cov_bio_sub$taxon.NUM <- as.numeric(factor(env_cov_bio_sub$taxon, levels = unique(env_cov_bio_sub$taxon)))
```

Taxa were coded as follows: 
```{r}
data.frame(taxon = levels(env_cov_bio_sub$taxon),
           num = unique(env_cov_bio_sub$taxon.NUM))
```

Numeric predictors were scaled and centered: 
```{r}
num_pred <- env_cov_bio_sub %>% select(tempjja,
                                       tempcont,
                                       precipjja,
                                       sri, 
                                       tcws,
                                       tri, 
                                       ends_with("_cover"),
                                       matches("compet"))
for(i in 1:length(num_pred)){
  col <- colnames(num_pred[i])
  env_cov_bio_sub[paste0(col,"C")] <- as.numeric(scale(num_pred[i], scale = TRUE, center = TRUE))
}
```

To account for the range of the cover response ($0 \leq cover \leq 1$), the model needs a mixed structure incorporating a beta distribution (for all continuous values with $0 < cover < 1$) and a binomial distribution (for all discrete values of $cover = \{0, 1\}$). An additional variable *cover_discrete* was introduced to separate the dataset into discrete (= 1) and continuous (= 0) cover values:
```{r}
env_cov_bio_sub$cover_discrete <- ifelse(env_cov_bio_sub$cover == 1 | env_cov_bio_sub$cover == 0, 1, 0)
```


<br>

### All groups & species
The dataset was then ready to be split up into the species of interest. We create separate data subsets for all/discrete/continuous response variable values for each species:
```{r}
# split dataframe by taxon
env_cov_bio_sub_spec.tot <- split(env_cov_bio_sub, env_cov_bio_sub$taxon)

# assign taxon name to list elements
# >> for total datasets
for (taxon_id in 1:nlevels(env_cov_bio_sub$taxon)){
  # extract 3-letter genus name string
  assign(paste0(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id], 
                            "^\\w{3}"),
  # extract and capitalise 3-letter species name string
                str_to_title(str_remove(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id],
                                                    "\\s\\w{3}"),
                                        "\\s")),
  # add extension
                ".tot"),
  # assign to respective list element
         env_cov_bio_sub_spec.tot[[taxon_id]])
}



# >> for discrete datasets
env_cov_bio_sub_spec.dis <- list()
for (taxon_id in 1:nlevels(env_cov_bio_sub$taxon)){
  # filter for discrete response values
  env_cov_bio_sub_spec.dis[[taxon_id]] <- filter(env_cov_bio_sub_spec.tot[[taxon_id]], cover_discrete == 1)
  # extract 3-letter genus name string
  assign(paste0(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id], 
                            "^\\w{3}"),
  # extract and capitalise 3-letter species name string
                str_to_title(str_remove(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id],
                                                    "\\s\\w{3}"),
                                        "\\s")),
  # add extension
                ".dis"),
  # assign to respective list element
         env_cov_bio_sub_spec.dis[[taxon_id]])
}

# >> for continuous datasets
env_cov_bio_sub_spec.cont <- list()
for (taxon_id in 1:nlevels(env_cov_bio_sub$taxon)){
  # filter for continuous response values
  env_cov_bio_sub_spec.cont[[taxon_id]] <- filter(env_cov_bio_sub_spec.tot[[taxon_id]], cover_discrete == 0)
  # extract 3-letter genus name string
  assign(paste0(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id], 
                            "^\\w{3}"),
  # extract and capitalise 3-letter species name string
                str_to_title(str_remove(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id],
                                                    "\\s\\w{3}"),
                                        "\\s")),
  # add extension
                ".cont"),
  # assign to respective list element
         env_cov_bio_sub_spec.cont[[taxon_id]])
}

```

### Groups
### > assembling data for model input in lists

JAGS needs data input in list format, so I provided all relevant variables as follows:
```{r}
# Compile data into lists
# All shrubs ----
shrub_gradient_jags.AllShr.data <- list(
  
  # plot level predictors
  cov.tot = AllShr.tot$cover + 1,
  plotgroup.tot = AllShr.tot$plotgroup.NUM,
  sri.tot = AllShr.tot$sriC,
  tri.tot = AllShr.tot$triC,
  tcws.tot = AllShr.tot$tcwsC,
  gramin_cov.tot = AllShr.tot$graminoid_coverC,
  tempjja.tot.plot = AllShr.tot$tempjjaC,
  N_plots = length(unique(AllShr.tot$plot)),
  
  # plot group level predictors
  tempjja.tot = AllShr.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = AllShr.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = AllShr.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(AllShr.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_graminoid_cover = seq(from = min(AllShr.tot$graminoid_coverC), to = max(AllShr.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(AllShr.tot$sriC), to = max(AllShr.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(AllShr.tot$triC), to = max(AllShr.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(AllShr.tot$tcwsC), to = max(AllShr.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(AllShr.tot$tempjjaC), to = max(AllShr.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(AllShr.tot$precipjjaC), to = max(AllShr.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(AllShr.tot$tempcontC), to = max(AllShr.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(AllShr.tot$tcwsC,0.05),quantile(AllShr.tot$tcwsC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.AllShr.data)

# All evergreen shrubs ----
shrub_gradient_jags.AllEve.data <- list(
  
  # plot level predictors
  cov.tot = AllEve.tot$cover + 1,
  plotgroup.tot = AllEve.tot$plotgroup.NUM,
  sri.tot = AllEve.tot$sriC,
  tri.tot = AllEve.tot$triC,
  tcws.tot = AllEve.tot$tcwsC,
  gramin_cov.tot = AllEve.tot$graminoid_coverC,
  tempjja.tot.plot = AllEve.tot$tempjjaC,
  N_plots = length(unique(AllEve.tot$plot)),
  
  # plot group level predictors
  tempjja.tot = AllEve.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = AllEve.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = AllEve.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(AllEve.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_graminoid_cover = seq(from = min(AllEve.tot$graminoid_coverC), to = max(AllEve.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(AllEve.tot$sriC), to = max(AllEve.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(AllEve.tot$triC), to = max(AllEve.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(AllEve.tot$tcwsC), to = max(AllEve.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(AllEve.tot$tempjjaC), to = max(AllEve.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(AllEve.tot$precipjjaC), to = max(AllEve.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(AllEve.tot$tempcontC), to = max(AllEve.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(AllEve.tot$tcwsC,0.05),quantile(AllEve.tot$tcwsC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.AllEve.data)

# All decidious shrubs ----
shrub_gradient_jags.AllDec.data <- list(
  
  # plot level predictors
  cov.tot = AllDec.tot$cover + 1,
  plotgroup.tot = AllDec.tot$plotgroup.NUM,
  sri.tot = AllDec.tot$sriC,
  tri.tot = AllDec.tot$triC,
  tcws.tot = AllDec.tot$tcwsC,
  gramin_cov.tot = AllDec.tot$graminoid_coverC,
  tempjja.tot.plot = AllDec.tot$tempjjaC,
  N_plots = length(unique(AllDec.tot$plot)),
  
  # plot group level predictors
  tempjja.tot = AllDec.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = AllDec.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = AllDec.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(AllDec.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_graminoid_cover = seq(from = min(AllDec.tot$graminoid_coverC), to = max(AllDec.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(AllDec.tot$sriC), to = max(AllDec.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(AllDec.tot$triC), to = max(AllDec.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(AllDec.tot$tcwsC), to = max(AllDec.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(AllDec.tot$tempjjaC), to = max(AllDec.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(AllDec.tot$precipjjaC), to = max(AllDec.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(AllDec.tot$tempcontC), to = max(AllDec.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(AllDec.tot$tcwsC,0.05),quantile(AllDec.tot$tcwsC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.AllDec.data)


# save model input data
shrub_gradient_jags.groupdata <- list

save(list = c("shrub_gradient_jags.AllShr.data",
              "shrub_gradient_jags.AllEve.data",
              "shrub_gradient_jags.AllDec.data"), 
     file = file.path("..", "data", "model_input_data", "shrub_gradient_jags.groupdata.Rdata"))
```

### > specifying model
```{r}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plot ~ dunif(0,100)
      tau.plot <- 1/(sigma.plot * sigma.plot)
      
      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      b.tempXtcws2 ~ dnorm(0, 0.001)
      
      
    # plot level

      for (i in 1:N_plots){ 
        cov.tot[i] ~ dlnorm(mu.plot[i], tau.plot)
        log(mu.plot[i]) <- b_plotgroup[plotgroup.tot[i]] + # ~= random effect of plot group
                        b.gramin_cov * gramin_cov.tot[i] + 
                        b.tcws * tcws.tot[i] + 
                        b.tempXtcws * tempjja.tot.plot[i] * tcws.tot[i] +       # for interaction
                        b.tempXtcws2 * (tempjja.tot.plot[i]^2) * tcws.tot[i] +  # for interaction
                        b.sri * sri.tot[i] +
                        b.tri * tri.tot[i]
      }


    # plot group level
    
      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] + 
                    b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] +
                                      b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
        }
      }

    
      }
  ", file.path("..", "models", "shrub_gradient.groups.jags"))
```

Specify the parameters to be monitored:
```{r}
params_groups <- c("intercept",
                   "b.tempjja.x", "b.tempjja.x2",
                   "b.tempcont.x", "b.tempcont.x2",
                   "b.precipjja.x", "b.precipjja.x2",
                   "b.gramin_cov",
                   "b.sri",
                   "b.tri",
                   "b.tcws",
                   "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                   "sigma.plotgroup",
                   "phat_graminoid_cover", 
                   "phat_sri", "phat_tcws", "phat_tri", 
                   "phat_tempjja", "phat_tempcont", "phat_precipjja",
                   "phat_tempXmoist")
```

### > run & evaluate model
<br>

### *All shrubs*
```{r}
# run model
model_out.shrub_gradient.AllShr <- jags(shrub_gradient_jags.AllShr.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_groups,                      # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.groups.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

# plot(model_out.shrub_gradient.AllShr) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.AllShr <- model_out.shrub_gradient.AllShr$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.AllShr),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.AllShr <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.AllShr$BUGSoutput$sims.list)-4)){
  ci_90.AllShr[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.AllShr$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.AllShr[param, 3] <- names(data.frame(model_out.shrub_gradient.AllShr$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.AllShr <- coeff.shrub_gradient.AllShr %>% 
  left_join(ci_90.AllShr, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

save(coeff.shrub_gradient.AllShr, file = file.path("..", "data", "model_outputs", "groups", "outdated", "model_output_AllShr.Rdata"))

(effect_size_plot.AllShr <- model_plot_sig_function(coeff.shrub_gradient.AllShr, title_string = "all shrubs", plot_width = 11))
```

* **evaluation (sig)**
* other remarks (n.s.)

<br>

As none of the quadratic terms come out significant, re-run without them:
```{r}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plot ~ dunif(0,100)
      tau.plot <- 1/(sigma.plot * sigma.plot)
      
      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      # b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      # b.tempXtcws2 ~ dnorm(0, 0.001)
      
      
    # plot level

      for (i in 1:N_plots){ 
        cov.tot[i] ~ dlnorm(mu.plot[i], tau.plot)
        log(mu.plot[i]) <- b_plotgroup[plotgroup.tot[i]] + # ~= random effect of plot group
                        b.gramin_cov * gramin_cov.tot[i] + 
                        b.tcws * tcws.tot[i] + 
                        b.tempXtcws * tempjja.tot.plot[i] * tcws.tot[i] +       # for interaction
                        # b.tempXtcws2 * (tempjja.tot.plot[i]^2) * tcws.tot[i] +  # for interaction
                        b.sri * sri.tot[i] +
                        b.tri * tri.tot[i]
      }


    # plot group level
    
      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    # b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    # b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] # + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] # + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] # + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      # b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] # +
                                      # b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
        }
      }

    
      }
  ", file.path("..", "models", "shrub_gradient.AllShr2.jags"))

# specify new set of parameters
params_AllShr2 <- c("intercept",
                   "b.tempjja.x", # "b.tempjja.x2",
                   "b.tempcont.x", # "b.tempcont.x2",
                   "b.precipjja.x", # "b.precipjja.x2",
                   "b.gramin_cov",
                   "b.sri",
                   "b.tri",
                   "b.tcws",
                   "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                   "sigma.plotgroup",
                   "phat_graminoid_cover", 
                   "phat_sri", "phat_tcws", "phat_tri", 
                   "phat_tempjja", "phat_tempcont", "phat_precipjja",
                   "phat_tempXmoist")

# run model
model_out.shrub_gradient.AllShr2 <- jags(shrub_gradient_jags.AllShr.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_AllShr2,                      # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.AllShr2.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

# plot(model_out.shrub_gradient.AllShr2) #check convergence, etc.
```
Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.AllShr2 <- model_out.shrub_gradient.AllShr2$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.AllShr2),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.AllShr2 <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.AllShr2$BUGSoutput$sims.list)-4)){
  ci_90.AllShr2[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.AllShr2$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.AllShr2[param, 3] <- names(data.frame(model_out.shrub_gradient.AllShr2$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.AllShr2 <- coeff.shrub_gradient.AllShr2 %>% 
  left_join(ci_90.AllShr2, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

save(coeff.shrub_gradient.AllShr2, file = file.path("..", "data", "model_outputs", "groups", "model_output_AllShr2.Rdata"))

(effect_size_plot.AllShr2 <- model_plot_sig_function(coeff.shrub_gradient.AllShr2, title_string = "all shrubs", plot_width = 7.5))
```

### *Evergreen shrubs*
```{r}
# run model
model_out.shrub_gradient.AllEve <- jags(shrub_gradient_jags.AllEve.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_groups,                      # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.groups.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

# plot(model_out.shrub_gradient.AllEve) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.AllEve <- model_out.shrub_gradient.AllEve$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.AllEve),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.AllEve <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.AllEve$BUGSoutput$sims.list)-4)){
  ci_90.AllEve[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.AllEve$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.AllEve[param, 3] <- names(data.frame(model_out.shrub_gradient.AllEve$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.AllEve <- coeff.shrub_gradient.AllEve %>% 
  left_join(ci_90.AllEve, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

save(coeff.shrub_gradient.AllEve, file = file.path("..", "data", "model_outputs", "groups", "outdated", "model_output_AllEve.Rdata"))

(effect_size_plot.AllEve <- model_plot_sig_function(coeff.shrub_gradient.AllEve, title_string = "evergreen shrubs", plot_width = 11))
```

* **evaluation (sig)**
* other remarks (n.s.)

<br>

```{r}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plot ~ dunif(0,100)
      tau.plot <- 1/(sigma.plot * sigma.plot)
      
      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      b.tempXtcws2 ~ dnorm(0, 0.001)
      
      
    # plot level

      for (i in 1:N_plots){ 
        cov.tot[i] ~ dlnorm(mu.plot[i], tau.plot)
        log(mu.plot[i]) <- b_plotgroup[plotgroup.tot[i]] + # ~= random effect of plot group
                        b.gramin_cov * gramin_cov.tot[i] + 
                        b.tcws * tcws.tot[i] + 
                        b.tempXtcws * tempjja.tot.plot[i] * tcws.tot[i] +       # for interaction
                        b.tempXtcws2 * (tempjja.tot.plot[i]^2) * tcws.tot[i] +  # for interaction
                        b.sri * sri.tot[i] +
                        b.tri * tri.tot[i]
      }


    # plot group level
    
      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    # b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] # + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] # + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] +
                                      b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
        }
      }

    
      }
  ", file.path("..", "models", "shrub_gradient.AllEve2.jags"))

# specify new set of parameters
params_AllEve2 <- c("intercept",
                   "b.tempjja.x", "b.tempjja.x2",
                   "b.tempcont.x", # "b.tempcont.x2",
                   "b.precipjja.x", # "b.precipjja.x2",
                   "b.gramin_cov",
                   "b.sri",
                   "b.tri",
                   "b.tcws",
                   "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                   "sigma.plotgroup",
                   "phat_graminoid_cover", 
                   "phat_sri", "phat_tcws", "phat_tri", 
                   "phat_tempjja", "phat_tempcont", "phat_precipjja",
                   "phat_tempXmoist")

# run model
model_out.shrub_gradient.AllEve2 <- jags(shrub_gradient_jags.AllEve.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_AllEve2,                      # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.AllEve2.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

# plot(model_out.shrub_gradient.AllShr2) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.AllEve2 <- model_out.shrub_gradient.AllEve2$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.AllEve),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.AllEve2 <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.AllEve2$BUGSoutput$sims.list)-4)){
  ci_90.AllEve2[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.AllEve2$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.AllEve2[param, 3] <- names(data.frame(model_out.shrub_gradient.AllEve2$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.AllEve2 <- coeff.shrub_gradient.AllEve2 %>% 
  left_join(ci_90.AllEve2, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.AllEve2, file = file.path("..", "data", "model_outputs", "groups", "model_output_AllEve2.Rdata"))

(effect_size_plot.AllEve2 <- model_plot_sig_function(coeff.shrub_gradient.AllEve2, title_string = "evergreen shrubs", plot_width = 8.5))
```

### *Deciduous shrubs*
```{r}
# run model
model_out.shrub_gradient.AllDec <- jags(shrub_gradient_jags.AllDec.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_groups,                      # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.groups.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

# plot(model_out.shrub_gradient.AllDec) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.AllDec <- model_out.shrub_gradient.AllDec$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.AllDec),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.AllDec <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.AllDec$BUGSoutput$sims.list)-4)){
  ci_90.AllDec[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.AllDec$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.AllDec[param, 3] <- names(data.frame(model_out.shrub_gradient.AllDec$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.AllDec <- coeff.shrub_gradient.AllDec %>% 
  left_join(ci_90.AllDec, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.AllDec, file = file.path("..", "data", "model_outputs", "groups", "outdated", "model_output_AllDec.Rdata"))

(effect_size_plot.AllDec <- model_plot_marg_function(coeff.shrub_gradient.AllDec, title_string = "deciduous shrubs", plot_width = 11))
```

* **evaluation (sig)**
* other remarks (n.s.)

<br>

```{r}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plot ~ dunif(0,100)
      tau.plot <- 1/(sigma.plot * sigma.plot)
      
      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      # b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      # b.tempXtcws2 ~ dnorm(0, 0.001)
      
      
    # plot level

      for (i in 1:N_plots){ 
        cov.tot[i] ~ dlnorm(mu.plot[i], tau.plot)
        log(mu.plot[i]) <- b_plotgroup[plotgroup.tot[i]] + # ~= random effect of plot group
                        b.gramin_cov * gramin_cov.tot[i] + 
                        b.tcws * tcws.tot[i] + 
                        b.tempXtcws * tempjja.tot.plot[i] * tcws.tot[i] +       # for interaction
                        # b.tempXtcws2 * (tempjja.tot.plot[i]^2) * tcws.tot[i] +  # for interaction
                        b.sri * sri.tot[i] +
                        b.tri * tri.tot[i]
      }


    # plot group level
    
      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    # b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] # + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] # + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      # b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] # +
                                      # b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
        }
      }

    
      }
  ", file.path("..", "models", "shrub_gradient.AllDec2.jags"))

# specify new set of parameters
params_AllDec2 <- c("intercept",
                   "b.tempjja.x", # "b.tempjja.x2",
                   "b.tempcont.x", "b.tempcont.x2",
                   "b.precipjja.x", # "b.precipjja.x2",
                   "b.gramin_cov",
                   "b.sri",
                   "b.tri",
                   "b.tcws",
                   "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                   "sigma.plotgroup",
                   "phat_graminoid_cover", 
                   "phat_sri", "phat_tcws", "phat_tri", 
                   "phat_tempjja", "phat_tempcont", "phat_precipjja",
                   "phat_tempXmoist")

# run model
model_out.shrub_gradient.AllDec2 <- jags(shrub_gradient_jags.AllDec.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_AllDec2,                      # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.AllDec2.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

# plot(model_out.shrub_gradient.AllDec2) #check convergence, etc.
```
Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.AllDec2 <- model_out.shrub_gradient.AllDec2$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.AllDec2),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.AllDec2 <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.AllDec2$BUGSoutput$sims.list)-4)){
  ci_90.AllDec2[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.AllDec2$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.AllDec2[param, 3] <- names(data.frame(model_out.shrub_gradient.AllDec2$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.AllDec2 <- coeff.shrub_gradient.AllDec2 %>% 
  left_join(ci_90.AllDec2, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

save(coeff.shrub_gradient.AllDec2, file = file.path("..", "data", "model_outputs", "groups", "model_output_AllDec2.Rdata"))

(effect_size_plot.AllDec2 <- model_plot_sig_function(coeff.shrub_gradient.AllDec2, title_string = "deciduous shrubs", plot_width = 8.5))
```

### Species
### > species: assembling data for model input in lists

```{r}
# BetNan ----
shrub_gradient_jags.BetNan.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = BetNan.dis$cover,
  plotgroup.dis = BetNan.dis$plotgroup.NUM,
  tempjja.dis = BetNan.dis$tempjjaC,
  sri.dis = BetNan.dis$sriC,
  tri.dis = BetNan.dis$triC,
  tcws.dis = BetNan.dis$tcwsC,
  shrub_cov.dis = BetNan.dis$BetNan_shrub_coverC,
  gramin_cov.dis = BetNan.dis$graminoid_coverC,
  compet.dis = BetNan.dis$competC,
  N_discrete = nrow(BetNan.dis),
  
  # ...and continuous part of the data
  cov.cont = BetNan.cont$cover,
  plotgroup.cont = BetNan.cont$plotgroup.NUM,
  tempjja.cont = BetNan.cont$tempjjaC,
  sri.cont = BetNan.cont$sriC,
  tri.cont = BetNan.cont$triC,
  tcws.cont = BetNan.cont$tcwsC,
  shrub_cov.cont = BetNan.cont$BetNan_shrub_coverC,
  gramin_cov.cont = BetNan.cont$graminoid_coverC,
  compet.cont = BetNan.cont$competC,
  N_cont = nrow(BetNan.cont),
  
  # plot group level predictors
  tempjja.tot = BetNan.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = BetNan.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = BetNan.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(BetNan.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(BetNan.tot$competC), to = max(BetNan.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(BetNan.tot$BetNan_shrub_coverC), to = max(BetNan.tot$BetNan_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(BetNan.tot$graminoid_coverC), to = max(BetNan.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(BetNan.tot$sriC), to = max(BetNan.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(BetNan.tot$triC), to = max(BetNan.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(BetNan.tot$tcwsC), to = max(BetNan.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(BetNan.tot$tempjjaC), to = max(BetNan.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(BetNan.tot$precipjjaC), to = max(BetNan.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(BetNan.tot$tempcontC), to = max(BetNan.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(BetNan.tot$tcwsC,0.05),quantile(BetNan.tot$tcwsC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.BetNan.data)

# CasTet ----
shrub_gradient_jags.CasTet.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = CasTet.dis$cover,
  plotgroup.dis = CasTet.dis$plotgroup.NUM,
  tempjja.dis = CasTet.dis$tempjjaC,
  sri.dis = CasTet.dis$sriC,
  tri.dis = CasTet.dis$triC,
  tcws.dis = CasTet.dis$tcwsC,
  shrub_cov.dis = CasTet.dis$CasTet_shrub_coverC,
  gramin_cov.dis = CasTet.dis$graminoid_coverC,
  compet.dis = CasTet.dis$competC,
  N_discrete = nrow(CasTet.dis),
  
  # ...and continuous part of the data
  cov.cont = CasTet.cont$cover,
  plotgroup.cont = CasTet.cont$plotgroup.NUM,
  tempjja.cont = CasTet.cont$tempjjaC,
  sri.cont = CasTet.cont$sriC,
  tri.cont = CasTet.cont$triC,
  tcws.cont = CasTet.cont$tcwsC,
  shrub_cov.cont = CasTet.cont$CasTet_shrub_coverC,
  gramin_cov.cont = CasTet.cont$graminoid_coverC,
  compet.cont = CasTet.cont$competC,
  N_cont = nrow(CasTet.cont),
  
  # plot group level predictors
  tempjja.tot = CasTet.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = CasTet.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = CasTet.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(CasTet.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(CasTet.tot$competC), to = max(CasTet.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(CasTet.tot$CasTet_shrub_coverC), to = max(CasTet.tot$CasTet_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(CasTet.tot$graminoid_coverC), to = max(CasTet.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(CasTet.tot$sriC), to = max(CasTet.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(CasTet.tot$triC), to = max(CasTet.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(CasTet.tot$tcwsC), to = max(CasTet.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(CasTet.tot$tempjjaC), to = max(CasTet.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(CasTet.tot$precipjjaC), to = max(CasTet.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(CasTet.tot$tempcontC), to = max(CasTet.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(CasTet.tot$tempjjaC,0.05),quantile(CasTet.tot$tempjjaC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.CasTet.data)

# EmpNig ----
shrub_gradient_jags.EmpNig.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = EmpNig.dis$cover,
  plotgroup.dis = EmpNig.dis$plotgroup.NUM,
  tempjja.dis = EmpNig.dis$tempjjaC,
  sri.dis = EmpNig.dis$sriC,
  tri.dis = EmpNig.dis$triC,
  tcws.dis = EmpNig.dis$tcwsC,
  shrub_cov.dis = EmpNig.dis$EmpNig_shrub_coverC,
  gramin_cov.dis = EmpNig.dis$graminoid_coverC,
  compet.dis = EmpNig.dis$competC,
  N_discrete = nrow(EmpNig.dis),
  
  # ...and continuous part of the data
  cov.cont = EmpNig.cont$cover,
  plotgroup.cont = EmpNig.cont$plotgroup.NUM,
  tempjja.cont = EmpNig.cont$tempjjaC,
  sri.cont = EmpNig.cont$sriC,
  tri.cont = EmpNig.cont$triC,
  tcws.cont = EmpNig.cont$tcwsC,
  shrub_cov.cont = EmpNig.cont$EmpNig_shrub_coverC,
  gramin_cov.cont = EmpNig.cont$graminoid_coverC,
  compet.cont = EmpNig.cont$competC,
  N_cont = nrow(EmpNig.cont),
  
  # plot group level predictors
  tempjja.tot = EmpNig.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = EmpNig.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = EmpNig.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(EmpNig.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(EmpNig.tot$competC), to = max(EmpNig.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(EmpNig.tot$EmpNig_shrub_coverC), to = max(EmpNig.tot$EmpNig_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(EmpNig.tot$graminoid_coverC), to = max(EmpNig.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(EmpNig.tot$sriC), to = max(EmpNig.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(EmpNig.tot$triC), to = max(EmpNig.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(EmpNig.tot$tcwsC), to = max(EmpNig.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(EmpNig.tot$tempjjaC), to = max(EmpNig.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(EmpNig.tot$precipjjaC), to = max(EmpNig.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(EmpNig.tot$tempcontC), to = max(EmpNig.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(EmpNig.tot$tempjjaC,0.05),quantile(EmpNig.tot$tempjjaC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.EmpNig.data)

# PhyCae ----
shrub_gradient_jags.PhyCae.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = PhyCae.dis$cover,
  plotgroup.dis = PhyCae.dis$plotgroup.NUM,
  tempjja.dis = PhyCae.dis$tempjjaC,
  sri.dis = PhyCae.dis$sriC,
  tri.dis = PhyCae.dis$triC,
  tcws.dis = PhyCae.dis$tcwsC,
  shrub_cov.dis = PhyCae.dis$PhyCae_shrub_coverC,
  gramin_cov.dis = PhyCae.dis$graminoid_coverC,
  compet.dis = PhyCae.dis$competC,
  N_discrete = nrow(PhyCae.dis),
  
  # ...and continuous part of the data
  cov.cont = PhyCae.cont$cover,
  plotgroup.cont = PhyCae.cont$plotgroup.NUM,
  tempjja.cont = PhyCae.cont$tempjjaC,
  sri.cont = PhyCae.cont$sriC,
  tri.cont = PhyCae.cont$triC,
  tcws.cont = PhyCae.cont$tcwsC,
  shrub_cov.cont = PhyCae.cont$PhyCae_shrub_coverC,
  gramin_cov.cont = PhyCae.cont$graminoid_coverC,
  compet.cont = PhyCae.cont$competC,
  N_cont = nrow(PhyCae.cont),
  
  # plot group level predictors
  tempjja.tot = PhyCae.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = PhyCae.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = PhyCae.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(PhyCae.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(PhyCae.tot$competC), to = max(PhyCae.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(PhyCae.tot$PhyCae_shrub_coverC), to = max(PhyCae.tot$PhyCae_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(PhyCae.tot$graminoid_coverC), to = max(PhyCae.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(PhyCae.tot$sriC), to = max(PhyCae.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(PhyCae.tot$triC), to = max(PhyCae.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(PhyCae.tot$tcwsC), to = max(PhyCae.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(PhyCae.tot$tempjjaC), to = max(PhyCae.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(PhyCae.tot$precipjjaC), to = max(PhyCae.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(PhyCae.tot$tempcontC), to = max(PhyCae.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(PhyCae.tot$tempjjaC,0.05),quantile(PhyCae.tot$tempjjaC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.PhyCae.data)

# RhoGro ----
shrub_gradient_jags.RhoGro.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = RhoGro.dis$cover,
  plotgroup.dis = RhoGro.dis$plotgroup.NUM,
  tempjja.dis = RhoGro.dis$tempjjaC,
  sri.dis = RhoGro.dis$sriC,
  tri.dis = RhoGro.dis$triC,
  tcws.dis = RhoGro.dis$tcwsC,
  shrub_cov.dis = RhoGro.dis$RhoGro_shrub_coverC,
  gramin_cov.dis = RhoGro.dis$graminoid_coverC,
  compet.dis = RhoGro.dis$competC,
  N_discrete = nrow(RhoGro.dis),
  
  # ...and continuous part of the data
  cov.cont = RhoGro.cont$cover,
  plotgroup.cont = RhoGro.cont$plotgroup.NUM,
  tempjja.cont = RhoGro.cont$tempjjaC,
  sri.cont = RhoGro.cont$sriC,
  tri.cont = RhoGro.cont$triC,
  tcws.cont = RhoGro.cont$tcwsC,
  shrub_cov.cont = RhoGro.cont$RhoGro_shrub_coverC,
  gramin_cov.cont = RhoGro.cont$graminoid_coverC,
  compet.cont = RhoGro.cont$competC,
  N_cont = nrow(RhoGro.cont),
  
  # plot group level predictors
  tempjja.tot = RhoGro.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = RhoGro.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = RhoGro.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(RhoGro.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(RhoGro.tot$competC), to = max(RhoGro.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(RhoGro.tot$RhoGro_shrub_coverC), to = max(RhoGro.tot$RhoGro_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(RhoGro.tot$graminoid_coverC), to = max(RhoGro.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(RhoGro.tot$sriC), to = max(RhoGro.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(RhoGro.tot$triC), to = max(RhoGro.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(RhoGro.tot$tcwsC), to = max(RhoGro.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(RhoGro.tot$tempjjaC), to = max(RhoGro.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(RhoGro.tot$precipjjaC), to = max(RhoGro.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(RhoGro.tot$tempcontC), to = max(RhoGro.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(RhoGro.tot$tempjjaC,0.05),quantile(RhoGro.tot$tempjjaC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.RhoGro.data)

# RhoTom ----
shrub_gradient_jags.RhoTom.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = RhoTom.dis$cover,
  plotgroup.dis = RhoTom.dis$plotgroup.NUM,
  tempjja.dis = RhoTom.dis$tempjjaC,
  sri.dis = RhoTom.dis$sriC,
  tri.dis = RhoTom.dis$triC,
  tcws.dis = RhoTom.dis$tcwsC,
  shrub_cov.dis = RhoTom.dis$RhoTom_shrub_coverC,
  gramin_cov.dis = RhoTom.dis$graminoid_coverC,
  compet.dis = RhoTom.dis$competC,
  N_discrete = nrow(RhoTom.dis),
  
  # ...and continuous part of the data
  cov.cont = RhoTom.cont$cover,
  plotgroup.cont = RhoTom.cont$plotgroup.NUM,
  tempjja.cont = RhoTom.cont$tempjjaC,
  sri.cont = RhoTom.cont$sriC,
  tri.cont = RhoTom.cont$triC,
  tcws.cont = RhoTom.cont$tcwsC,
  shrub_cov.cont = RhoTom.cont$RhoTom_shrub_coverC,
  gramin_cov.cont = RhoTom.cont$graminoid_coverC,
  compet.cont = RhoTom.cont$competC,
  N_cont = nrow(RhoTom.cont),
  
  # plot group level predictors
  tempjja.tot = RhoTom.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = RhoTom.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = RhoTom.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(RhoTom.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(RhoTom.tot$competC), to = max(RhoTom.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(RhoTom.tot$RhoTom_shrub_coverC), to = max(RhoTom.tot$RhoTom_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(RhoTom.tot$graminoid_coverC), to = max(RhoTom.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(RhoTom.tot$sriC), to = max(RhoTom.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(RhoTom.tot$triC), to = max(RhoTom.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(RhoTom.tot$tcwsC), to = max(RhoTom.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(RhoTom.tot$tempjjaC), to = max(RhoTom.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(RhoTom.tot$precipjjaC), to = max(RhoTom.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(RhoTom.tot$tempcontC), to = max(RhoTom.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(RhoTom.tot$tempjjaC,0.05),quantile(RhoTom.tot$tempjjaC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.RhoTom.data)

# SalArc ----
shrub_gradient_jags.SalArc.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = SalArc.dis$cover,
  plotgroup.dis = SalArc.dis$plotgroup.NUM,
  tempjja.dis = SalArc.dis$tempjjaC,
  sri.dis = SalArc.dis$sriC,
  tri.dis = SalArc.dis$triC,
  tcws.dis = SalArc.dis$tcwsC,
  shrub_cov.dis = SalArc.dis$SalArc_shrub_coverC,
  gramin_cov.dis = SalArc.dis$graminoid_coverC,
  compet.dis = SalArc.dis$competC,
  N_discrete = nrow(SalArc.dis),
  
  # ...and continuous part of the data
  cov.cont = SalArc.cont$cover,
  plotgroup.cont = SalArc.cont$plotgroup.NUM,
  tempjja.cont = SalArc.cont$tempjjaC,
  sri.cont = SalArc.cont$sriC,
  tri.cont = SalArc.cont$triC,
  tcws.cont = SalArc.cont$tcwsC,
  shrub_cov.cont = SalArc.cont$SalArc_shrub_coverC,
  gramin_cov.cont = SalArc.cont$graminoid_coverC,
  compet.cont = SalArc.cont$competC,
  N_cont = nrow(SalArc.cont),
  
  # plot group level predictors
  tempjja.tot = SalArc.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = SalArc.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = SalArc.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(SalArc.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(SalArc.tot$competC), to = max(SalArc.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(SalArc.tot$SalArc_shrub_coverC), to = max(SalArc.tot$SalArc_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(SalArc.tot$graminoid_coverC), to = max(SalArc.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(SalArc.tot$sriC), to = max(SalArc.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(SalArc.tot$triC), to = max(SalArc.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(SalArc.tot$tcwsC), to = max(SalArc.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(SalArc.tot$tempjjaC), to = max(SalArc.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(SalArc.tot$precipjjaC), to = max(SalArc.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(SalArc.tot$tempcontC), to = max(SalArc.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(SalArc.tot$tempjjaC,0.05),quantile(SalArc.tot$tempjjaC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.SalArc.data)

# SalGla ----
shrub_gradient_jags.SalGla.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = SalGla.dis$cover,
  plotgroup.dis = SalGla.dis$plotgroup.NUM,
  tempjja.dis = SalGla.dis$tempjjaC,
  sri.dis = SalGla.dis$sriC,
  tri.dis = SalGla.dis$triC,
  tcws.dis = SalGla.dis$tcwsC,
  shrub_cov.dis = SalGla.dis$SalGla_shrub_coverC,
  gramin_cov.dis = SalGla.dis$graminoid_coverC,
  compet.dis = SalGla.dis$competC,
  N_discrete = nrow(SalGla.dis),
  
  # ...and continuous part of the data
  cov.cont = SalGla.cont$cover,
  plotgroup.cont = SalGla.cont$plotgroup.NUM,
  tempjja.cont = SalGla.cont$tempjjaC,
  sri.cont = SalGla.cont$sriC,
  tri.cont = SalGla.cont$triC,
  tcws.cont = SalGla.cont$tcwsC,
  shrub_cov.cont = SalGla.cont$SalGla_shrub_coverC,
  gramin_cov.cont = SalGla.cont$graminoid_coverC,
  compet.cont = SalGla.cont$competC,
  N_cont = nrow(SalGla.cont),
  
  # plot group level predictors
  tempjja.tot = SalGla.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = SalGla.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = SalGla.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(SalGla.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(SalGla.tot$competC), to = max(SalGla.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(SalGla.tot$SalGla_shrub_coverC), to = max(SalGla.tot$SalGla_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(SalGla.tot$graminoid_coverC), to = max(SalGla.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(SalGla.tot$sriC), to = max(SalGla.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(SalGla.tot$triC), to = max(SalGla.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(SalGla.tot$tcwsC), to = max(SalGla.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(SalGla.tot$tempjjaC), to = max(SalGla.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(SalGla.tot$precipjjaC), to = max(SalGla.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(SalGla.tot$tempcontC), to = max(SalGla.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(SalGla.tot$tempjjaC,0.05),quantile(SalGla.tot$tempjjaC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.SalGla.data)

# VacUli ----
shrub_gradient_jags.VacUli.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = VacUli.dis$cover,
  plotgroup.dis = VacUli.dis$plotgroup.NUM,
  tempjja.dis = VacUli.dis$tempjjaC,
  sri.dis = VacUli.dis$sriC,
  tri.dis = VacUli.dis$triC,
  tcws.dis = VacUli.dis$tcwsC,
  shrub_cov.dis = VacUli.dis$VacUli_shrub_coverC,
  gramin_cov.dis = VacUli.dis$graminoid_coverC,
  compet.dis = VacUli.dis$competC,
  N_discrete = nrow(VacUli.dis),
  
  # ...and continuous part of the data
  cov.cont = VacUli.cont$cover,
  plotgroup.cont = VacUli.cont$plotgroup.NUM,
  tempjja.cont = VacUli.cont$tempjjaC,
  sri.cont = VacUli.cont$sriC,
  tri.cont = VacUli.cont$triC,
  tcws.cont = VacUli.cont$tcwsC,
  shrub_cov.cont = VacUli.cont$VacUli_shrub_coverC,
  gramin_cov.cont = VacUli.cont$graminoid_coverC,
  compet.cont = VacUli.cont$competC,
  N_cont = nrow(VacUli.cont),
  
  # plot group level predictors
  tempjja.tot = VacUli.tot %>% group_by(plotgroup.NUM) %>% summarise(tempjja.tot = mean(tempjjaC)) %>% pull(tempjja.tot), # one value per tXpg
  tempcont.tot = VacUli.tot %>% group_by(plotgroup.NUM) %>% summarise(tempcont.tot = mean(tempcontC)) %>% pull(tempcont.tot),
  precipjja.tot = VacUli.tot %>% group_by(plotgroup.NUM) %>% summarise(precipjja.tot = mean(precipjjaC)) %>% pull(precipjja.tot),
  N_plotgroups = length(unique(VacUli.tot$site_alt_plotgroup_id)),
  
  # subset of values for prediction, for each predictor...
  xhat_compet = seq(from = min(VacUli.tot$competC), to = max(VacUli.tot$competC), length.out = 100),
  xhat_shrub_cover = seq(from = min(VacUli.tot$VacUli_shrub_coverC), to = max(VacUli.tot$VacUli_shrub_coverC), length.out = 100),
  xhat_graminoid_cover = seq(from = min(VacUli.tot$graminoid_coverC), to = max(VacUli.tot$graminoid_coverC), length.out = 100),
  xhat_sri = seq(from = min(VacUli.tot$sriC), to = max(VacUli.tot$sriC), length.out = 100),
  xhat_tri = seq(from = min(VacUli.tot$triC), to = max(VacUli.tot$triC), length.out = 100),
  xhat_tcws = seq(from = min(VacUli.tot$tcwsC), to = max(VacUli.tot$tcwsC), length.out = 100),
  xhat_tempjja = seq(from = min(VacUli.tot$tempjjaC), to = max(VacUli.tot$tempjjaC), length.out = 100),
  xhat_precipjja = seq(from = min(VacUli.tot$precipjjaC), to = max(VacUli.tot$precipjjaC), length.out = 100),
  xhat_tempcont = seq(from = min(VacUli.tot$tempcontC), to = max(VacUli.tot$tempcontC), length.out = 100),
  Nxhat = 100,
  
  # ... and for predicting at high/low temperature levels
  xhat_tcws2 = as.numeric(c(quantile(VacUli.tot$tempjjaC,0.05),quantile(VacUli.tot$tempjjaC,0.95))), 
  Nxhat2 = 2
)
str(shrub_gradient_jags.VacUli.data)


# save model input data
save(list = c("shrub_gradient_jags.BetNan.data",
              "shrub_gradient_jags.CasTet.data",
              "shrub_gradient_jags.EmpNig.data",
              "shrub_gradient_jags.PhyCae.data",
              "shrub_gradient_jags.RhoGro.data",
              "shrub_gradient_jags.RhoTom.data",
              "shrub_gradient_jags.SalArc.data",
              "shrub_gradient_jags.SalGla.data",
              "shrub_gradient_jags.VacUli.data"), 
     file = file.path("..", "data", "model_input_data", "shrub_gradient_jags.speciesdata.Rdata"))
```

### > specifying model
```{r}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.shrub_cov ~ dnorm(0, 0.0001)
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      b.tempXtcws2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + # ~= random effect of plot group
                        b.compet * compet.dis[i] + 
                        b.shrub_cov * shrub_cov.dis[i] + 
                        b.gramin_cov * gramin_cov.dis[i] + 
                        b.tempXtcws * tempjja.dis[i] * tcws.dis[i] +       # for interaction
                        b.tempXtcws2 * (tempjja.dis[i]^2) * tcws.dis[i] +  # for interaction
                        b.tcws * tcws.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + # ~= random effect of plot group
                        b.compet * compet.cont[j] +
                        b.shrub_cov * shrub_cov.cont[j] +
                        b.gramin_cov * gramin_cov.cont[j] +
                        b.tempXtcws * tempjja.cont[j] * tcws.cont[j] +       # for interaction
                        b.tempXtcws2 * (tempjja.cont[j]^2) * tcws.cont[j] +  # for interaction
                        b.tcws * tcws.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] + 
                    b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_compet[m] <- intercept + b.compet * xhat_compet[m]
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_shrub_cover[m] <- intercept + b.shrub_cov * xhat_shrub_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] +
                                      b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
          }
        }

    
      }
  ", file.path("..", "models", "shrub_gradient.spec.jags"))
```

Specify the parameters to be monitored:
```{r}
params <- c("intercept",
            "b.tempjja.x", "b.tempjja.x2",
            "b.tempcont.x", "b.tempcont.x2",
            "b.precipjja.x", "b.precipjja.x2",
            "b.compet",
            "b.shrub_cov", 
            "b.gramin_cov",
            "b.sri",
            "b.tri",
            "b.tcws",
            "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
            "sigma.plotgroup",
            "phi",
            "phat_compet", "phat_shrub_cover", "phat_graminoid_cover", 
            "phat_sri", "phat_tcws", "phat_tri", 
            "phat_tempjja", "phat_tempcont", "phat_precipjja", 
            "phat_tempXmoist")
```

### > run & evaluate model
<br>

### *Betula nana*
```{r}
# run model
model_out.shrub_gradient.BetNan <- jags(shrub_gradient_jags.BetNan.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

# plot(model_out.shrub_gradient.BetNan) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.BetNan <- model_out.shrub_gradient.BetNan$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.BetNan),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.BetNan <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.BetNan$BUGSoutput$sims.list)-4)){
  ci_90.BetNan[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.BetNan$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.BetNan[param, 3] <- names(data.frame(model_out.shrub_gradient.BetNan$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.BetNan <- coeff.shrub_gradient.BetNan %>% 
  left_join(ci_90.BetNan, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.BetNan, file = file.path("..", "data", "model_outputs", "species", "outdated", "model_output_BetNan.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "outdated", "model_output_BetNan.Rdata"))

(effect_size_plot.BetNan <- model_plot_sig_function(coeff.shrub_gradient.BetNan, title_string = "Betula nana", plot_width = 12.5))
```

* **unimodal response to temperature variability (sig)**
* slightly negative response to competition & precipitation (linear) (n.s.)

<br>

As the quadratic terms for summer temperature and precipitation were not significant, they were removed from the model before re-running:
```{r}
# new model object with terms removed
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.shrub_cov ~ dnorm(0, 0.0001)
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      # b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      # b.tempXtcws2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + # ~= random effect of plot group
                        b.compet * compet.dis[i] + 
                        b.shrub_cov * shrub_cov.dis[i] + 
                        b.gramin_cov * gramin_cov.dis[i] + 
                        b.tempXtcws * tempjja.dis[i] * tcws.dis[i] +       # for interaction
                        # b.tempXtcws2 * (tempjja.dis[i]^2) * tcws.dis[i] +  # for interaction
                        b.tcws * tcws.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + # ~= random effect of plot group
                        b.compet * compet.cont[j] +
                        b.shrub_cov * shrub_cov.cont[j] +
                        b.gramin_cov * gramin_cov.cont[j] +
                        b.tempXtcws * tempjja.cont[j] * tcws.cont[j] +       # for interaction
                        # b.tempXtcws2 * (tempjja.cont[j]^2) * tcws.cont[j] +  # for interaction
                        b.tcws * tcws.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    # b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    # b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_compet[m] <- intercept + b.compet * xhat_compet[m]
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_shrub_cover[m] <- intercept + b.shrub_cov * xhat_shrub_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] # + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] # + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] # + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      # b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] # +
                                      # b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
          }
        }

    
      }
  ", file.path("..", "models", "shrub_gradient.BetNan2.jags"))

# specify new set of parameters to be monitored
params_BetNan2 <- c("intercept",
                    "b.tempjja.x", # "b.tempjja.x2",
                    "b.tempcont.x", # "b.tempcont.x2",
                    "b.precipjja.x", # "b.precipjja.x2",
                    "b.compet", 
                    "b.shrub_cov",
                    "b.gramin_cov",
                    "b.sri",
                    "b.tri",
                    "b.tcws",
                    "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                    "sigma.plotgroup",
                    "phi",
                    "phat_compet", "phat_shrub_cover", "phat_graminoid_cover", 
                    "phat_sri", "phat_tri", "phat_tcws", 
                    "phat_tempjja", "phat_tempcont", "phat_precipjja",
                    "phat_tempXmoist")

model_out.shrub_gradient.BetNan2 <- jags(shrub_gradient_jags.BetNan.data,   # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_BetNan2,                     # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.BetNan2.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.BetNan2) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.BetNan2 <- model_out.shrub_gradient.BetNan2$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")

# add 90% CIs
ci_90.BetNan2 <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list)-4)){
  ci_90.BetNan2[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.BetNan2[param, 3] <- names(data.frame(model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.BetNan2 <- coeff.shrub_gradient.BetNan2 %>% 
  left_join(ci_90.BetNan2, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.BetNan2, file.path("..", "data", "processed", "model_outputs", "species", "model_output_BetNan2.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "model_output_BetNan2.Rdata"))

# effect size plot
(effect_size_plot.BetNan2 <- model_plot_marg_function(coeff.shrub_gradient.BetNan2, title_string = "Betula nana", plot_width = 10.5))

```

* *unimodal response to temperature variability (m.s.)*
* slightly negative response to competition & precipitation (linear) (n.s.)

<br>


### *Cassiope tetragona*
```{r}
model_out.shrub_gradient.CasTet <- jags(shrub_gradient_jags.CasTet.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.CasTet) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.CasTet <- model_out.shrub_gradient.CasTet$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.CasTet),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.CasTet <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.CasTet$BUGSoutput$sims.list)-4)){
  ci_90.CasTet[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.CasTet$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.CasTet[param, 3] <- names(data.frame(model_out.shrub_gradient.CasTet$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.CasTet <- coeff.shrub_gradient.CasTet %>% 
  left_join(ci_90.CasTet, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.CasTet, file = file.path("..", "data", "model_outputs", "species", "model_output_CasTet.Rdata"))

```

* **not converging**: really large R-hat values (only 16 non-zero values)
<br>

### *Empetrum nigrum*
```{r}
model_out.shrub_gradient.EmpNig <- jags(shrub_gradient_jags.EmpNig.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.EmpNig) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.EmpNig <- model_out.shrub_gradient.EmpNig$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.EmpNig),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.EmpNig <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.EmpNig$BUGSoutput$sims.list)-4)){
  ci_90.EmpNig[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.EmpNig$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.EmpNig[param, 3] <- names(data.frame(model_out.shrub_gradient.EmpNig$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.EmpNig <- coeff.shrub_gradient.EmpNig %>% 
  left_join(ci_90.EmpNig, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.EmpNig, file = file.path("..", "data", "model_outputs", "species", "outdated", "model_output_EmpNig.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "outdated", "model_output_EmpNig.Rdata"))

# effect size plot
(effect_size_plot.EmpNig <- model_plot_sig_function(coeff.shrub_gradient.EmpNig, title_string = "Empetrum nigrum", plot_width = 12.5))

```

* **positive response to precipitation (linear, sig.)**
* *unimodal response to temperature (m.s.)*
* slightly positive response to competition, SRI and TWI (n.s.)
<br>

As the quadratic terms for temperature variability and precipitation were not significant, they were removed from the model before re-running:
```{r}
# new model object with terms removed
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.shrub_cov ~ dnorm(0, 0.0001)
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      # b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      # b.tempXtcws2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + # ~= random effect of plot group
                        b.compet * compet.dis[i] + 
                        b.shrub_cov * shrub_cov.dis[i] + 
                        b.gramin_cov * gramin_cov.dis[i] + 
                        b.tempXtcws * tempjja.dis[i] * tcws.dis[i] +       # for interaction
                        # b.tempXtcws2 * (tempjja.dis[i]^2) * tcws.dis[i] +  # for interaction
                        b.tcws * tcws.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + # ~= random effect of plot group
                        b.compet * compet.cont[j] +
                        b.shrub_cov * shrub_cov.cont[j] +
                        b.gramin_cov * gramin_cov.cont[j] +
                        b.tempXtcws * tempjja.cont[j] * tcws.cont[j] +       # for interaction
                        # b.tempXtcws2 * (tempjja.cont[j]^2) * tcws.cont[j] +  # for interaction
                        b.tcws * tcws.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    # b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    # b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_compet[m] <- intercept + b.compet * xhat_compet[m]
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_shrub_cover[m] <- intercept + b.shrub_cov * xhat_shrub_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] # + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] # + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] # + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      # b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] # +
                                      # b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
          }
        }

    
      }
  ", file.path("..", "models", "shrub_gradient.EmpNig2.jags"))

# specify new set of parameters to be monitored
params_EmpNig2 <- c("intercept",
                    "b.tempjja.x", # "b.tempjja.x2",
                    "b.tempcont.x", # "b.tempcont.x2",
                    "b.precipjja.x", # "b.precipjja.x2",
                    "b.compet", 
                    "b.shrub_cov",
                    "b.gramin_cov",
                    "b.sri",
                    "b.tri",
                    "b.tcws",
                    "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                    "sigma.plotgroup",
                    "phi",
                    "phat_compet", "phat_shrub_cover", "phat_graminoid_cover", 
                    "phat_sri", "phat_tri", "phat_tcws", 
                    "phat_tempjja", "phat_tempcont", "phat_precipjja",
                    "phat_tempXmoist")

model_out.shrub_gradient.EmpNig2 <- jags(shrub_gradient_jags.EmpNig.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_EmpNig2,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.EmpNig2.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.EmpNig2) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.EmpNig2 <- model_out.shrub_gradient.EmpNig2$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")

# add 90% CIs
ci_90.EmpNig2 <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.EmpNig2$BUGSoutput$sims.list)-4)){
  ci_90.EmpNig2[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.EmpNig2$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.EmpNig2[param, 3] <- names(data.frame(model_out.shrub_gradient.EmpNig2$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.EmpNig2 <- coeff.shrub_gradient.EmpNig2 %>% 
  left_join(ci_90.EmpNig2, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.EmpNig2, file = file.path("..", "data", "model_outputs", "species", "model_output_EmpNig2.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "model_output_EmpNig2.Rdata"))

# effect size plot
(effect_size_plot.EmpNig2 <- model_plot_sig_function(coeff.shrub_gradient.EmpNig2, title_string = "Empetrum nigrum", plot_width = 10.5))

```

* **unimodal response to temperature, positive response to precipitation (linear) (sig.)**, *negative response to temp. variability (m.s.)*
* positive response to competition, TWI (n.s.)

<br>

### *Phyllodoce caerulea*
```{r}
model_out.shrub_gradient.PhyCae <- jags(shrub_gradient_jags.PhyCae.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.PhyCae) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.PhyCae <- model_out.shrub_gradient.PhyCae$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.PhyCae),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.PhyCae <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.PhyCae$BUGSoutput$sims.list)-4)){
  ci_90.PhyCae[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.PhyCae$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.PhyCae[param, 3] <- names(data.frame(model_out.shrub_gradient.PhyCae$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.PhyCae <- coeff.shrub_gradient.PhyCae %>% 
  left_join(ci_90.PhyCae, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.PhyCae, file = file.path("..", "data", "model_outputs", "species", "model_output_PhyCae.Rdata"))

```

* **not converged** (only 10 non-zero values)
<br>

### *Rhododendron groenlandicum*
```{r}
model_out.shrub_gradient.RhoGro <- jags(shrub_gradient_jags.RhoGro.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.RhoGro) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.RhoGro <- model_out.shrub_gradient.RhoGro$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.RhoGro),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.RhoGro <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.RhoGro$BUGSoutput$sims.list)-4)){
  ci_90.RhoGro[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.RhoGro$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.RhoGro[param, 3] <- names(data.frame(model_out.shrub_gradient.RhoGro$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.RhoGro <- coeff.shrub_gradient.RhoGro %>% 
  left_join(ci_90.RhoGro, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.RhoGro, file = file.path("..", "data", "model_outputs", "species", "outdated", "model_output_RhoGro.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "outdated", "model_output_RhoGro.Rdata"))

# effect size plot
(effect_size_plot.RhoGro <- model_plot_sig_function(coeff.shrub_gradient.RhoGro, title_string = "Rhododendron groenlandicum", plot_width = 11.5))

```

* **unimodal response to temperature & linear to precipitation (sig.)** 
* slightly positive response to SRI, temp. variation (n.s.)
* slightly negative responst to TWI (n.s.)
* large variation in competiton response as there was only one (however rare) taller-growing species in the system (*R. tomentosum*)

<br>

As the quadratic terms for temperature variability and precipitation were not significant, they were removed from the model before re-running:
```{r}
# new model object with terms removed
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.shrub_cov ~ dnorm(0, 0.0001)
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      b.tempXtcws2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + # ~= random effect of plot group
                        b.compet * compet.dis[i] + 
                        b.shrub_cov * shrub_cov.dis[i] + 
                        b.gramin_cov * gramin_cov.dis[i] + 
                        b.tempXtcws * tempjja.dis[i] * tcws.dis[i] +       # for interaction
                        b.tempXtcws2 * (tempjja.dis[i]^2) * tcws.dis[i] +  # for interaction
                        b.tcws * tcws.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + # ~= random effect of plot group
                        b.compet * compet.cont[j] +
                        b.shrub_cov * shrub_cov.cont[j] +
                        b.gramin_cov * gramin_cov.cont[j] +
                        b.tempXtcws * tempjja.cont[j] * tcws.cont[j] +       # for interaction
                        b.tempXtcws2 * (tempjja.cont[j]^2) * tcws.cont[j] +  # for interaction
                        b.tcws * tcws.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    # b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_compet[m] <- intercept + b.compet * xhat_compet[m]
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_shrub_cover[m] <- intercept + b.shrub_cov * xhat_shrub_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] # + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] # + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] +
                                      b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
          }
        }

    
      }
  ", file.path("..", "models", "shrub_gradient.RhoGro2.jags"))

# specify new set of parameters to be monitored
params_RhoGro2 <- c("intercept",
                    "b.tempjja.x", "b.tempjja.x2",
                    "b.tempcont.x", # "b.tempcont.x2",
                    "b.precipjja.x", # "b.precipjja.x2",
                    "b.compet", 
                    "b.shrub_cov",
                    "b.gramin_cov",
                    "b.sri",
                    "b.tri",
                    "b.tcws",
                    "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                    "sigma.plotgroup",
                    "phi",
                    "phat_compet", 
                    "phat_shrub_cover", "phat_graminoid_cover", 
                    "phat_sri", "phat_tri", "phat_tcws", 
                    "phat_tempjja", "phat_tempcont", "phat_precipjja",
                    "phat_tempXmoist")

model_out.shrub_gradient.RhoGro2 <- jags(shrub_gradient_jags.RhoGro.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_RhoGro2,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.RhoGro2.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.RhoGro2) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.RhoGro2 <- model_out.shrub_gradient.RhoGro2$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.RhoGro),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.RhoGro2 <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.RhoGro2$BUGSoutput$sims.list)-4)){
  ci_90.RhoGro2[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.RhoGro2$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.RhoGro2[param, 3] <- names(data.frame(model_out.shrub_gradient.RhoGro2$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.RhoGro2 <- coeff.shrub_gradient.RhoGro2 %>% 
  left_join(ci_90.RhoGro2, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.RhoGro2, file = file.path("..", "data", "model_outputs", "species", "model_output_RhoGro2.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "model_output_RhoGro2.Rdata"))

# effect size plot
(effect_size_plot.RhoGro2 <- model_plot_marg_function(coeff.shrub_gradient.RhoGro2, title_string = "Rhododendron groenlandicum", plot_width = 10.5))

```

* **unimodal response to temperature and negative response to precipitation (linear), positive response to temperature variability (sig.)**
* positive response to SRI (n.s.)
* large variation in competiton response as there was only one (however rare) taller-growing species in the system (*R. tomentosum*)

<br>

### *Rhododendron tomentosum*
```{r}
model_out.shrub_gradient.RhoTom <- jags(shrub_gradient_jags.RhoTom.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.RhoTom) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.RhoTom <- model_out.shrub_gradient.RhoTom$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.RhoTom),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.RhoTom <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.RhoTom$BUGSoutput$sims.list)-4)){
  ci_90.RhoTom[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.RhoTom$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.RhoTom[param, 3] <- names(data.frame(model_out.shrub_gradient.RhoTom$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.RhoTom <- coeff.shrub_gradient.RhoTom %>% 
  left_join(ci_90.RhoTom, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.RhoTom, file = file.path("..", "data", "model_outputs", "species", "model_output_RhoTom.Rdata"))

```

* **not converging**: relatively large R-hat values, large variation in parameter estimates (only 13 non-zero values)
<br>

### *Salix arctophila*
```{r}
model_out.shrub_gradient.SalArc <- jags(shrub_gradient_jags.SalArc.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.SalArc) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.SalArc <- model_out.shrub_gradient.SalArc$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.SalArc),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.SalArc <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.SalArc$BUGSoutput$sims.list)-4)){
  ci_90.SalArc[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.SalArc$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.SalArc[param, 3] <- names(data.frame(model_out.shrub_gradient.SalArc$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.SalArc <- coeff.shrub_gradient.SalArc %>% 
  left_join(ci_90.SalArc, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.SalArc, file = file.path("..", "data", "model_outputs", "species", "model_output_SalArc.Rdata"))

```

* **not converging well**: relatively large R-hat values, quite some variation in parameter estimates (only 13 non-zero values)
<br>

### *Salix glauca*
```{r}
model_out.shrub_gradient.SalGla <- jags(shrub_gradient_jags.SalGla.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.SalGla) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.SalGla <- model_out.shrub_gradient.SalGla$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.SalGla),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.SalGla <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.SalGla$BUGSoutput$sims.list)-4)){
  ci_90.SalGla[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.SalGla$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.SalGla[param, 3] <- names(data.frame(model_out.shrub_gradient.SalGla$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.SalGla <- coeff.shrub_gradient.SalGla %>% 
  left_join(ci_90.SalGla, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.SalGla, file = file.path("..", "data", "model_outputs", "species", "outdated", "model_output_SalGla.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "outdated", "model_output_SalGla.Rdata"))

# effect size plot
(effect_size_plot.SalGla <- model_plot_sig_function(coeff.shrub_gradient.SalGla, title_string = "Salix glauca", plot_width = 12.5))

```

* **positive response to competition (sig.)**
* slightly negative response to temperature & SRI (n.s.)

<br>

As the quadratic terms for summer temperature, temperature variability and summer precipitation were not significant, they were removed from the model before re-running:
```{r}
# new model object with terms removed
write("
  
  model{

    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.shrub_cov ~ dnorm(0, 0.0001)
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      # b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      # b.tempXtcws2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + # ~= random effect of plot group
                        b.compet * compet.dis[i] + 
                        b.shrub_cov * shrub_cov.dis[i] + 
                        b.gramin_cov * gramin_cov.dis[i] + 
                        b.tempXtcws * tempjja.dis[i] * tcws.dis[i] +       # for interaction
                        # b.tempXtcws2 * (tempjja.dis[i]^2) * tcws.dis[i] +  # for interaction
                        b.tcws * tcws.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + # ~= random effect of plot group
                        b.compet * compet.cont[j] +
                        b.shrub_cov * shrub_cov.cont[j] +
                        b.gramin_cov * gramin_cov.cont[j] +
                        b.tempXtcws * tempjja.cont[j] * tcws.cont[j] +       # for interaction
                        # b.tempXtcws2 * (tempjja.cont[j]^2) * tcws.cont[j] +  # for interaction
                        b.tcws * tcws.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    # b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    # b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_compet[m] <- intercept + b.compet * xhat_compet[m]
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_shrub_cover[m] <- intercept + b.shrub_cov * xhat_shrub_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] # + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] # + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] # + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      # b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] # +
                                      # b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
          }
        }

    
      }
  ", file.path("..", "models", "shrub_gradient.SalGla2.jags"))

# specify new set of parameters to be monitored
params_SalGla2 <- c("intercept",
                    "b.tempjja.x", # "b.tempjja.x2",
                    "b.tempcont.x", # "b.tempcont.x2",
                    "b.precipjja.x", # "b.precipjja.x2",
                    "b.compet", 
                    "b.shrub_cov",
                    "b.gramin_cov",
                    "b.sri",
                    "b.tri",
                    "b.tcws",
                    "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                    "sigma.plotgroup",
                    "phi",
                    "phat_compet", "phat_shrub_cover", "phat_graminoid_cover", 
                    "phat_sri", "phat_tri", "phat_tcws", 
                    "phat_tempjja", "phat_tempcont", "phat_precipjja",
                    "phat_tempXmoist")

model_out.shrub_gradient.SalGla2 <- jags(shrub_gradient_jags.SalGla.data,   # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_SalGla2,                     # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.SalGla2.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.SalGla2) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.SalGla2 <- model_out.shrub_gradient.SalGla2$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")

# add 90% CIs
ci_90.SalGla2 <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.SalGla$BUGSoutput$sims.list)-4)){
  ci_90.SalGla2[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.SalGla2$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.SalGla2[param, 3] <- names(data.frame(model_out.shrub_gradient.SalGla2$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.SalGla2 <- coeff.shrub_gradient.SalGla2 %>% 
  left_join(ci_90.SalGla2, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.SalGla2, file = file.path("..", "data", "model_outputs", "species", "model_output_SalGla2.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "model_output_SalGla2.Rdata"))

# effect size plot
(effect_size_plot.SalGla2 <- model_plot_marg_function(coeff.shrub_gradient.SalGla2, title_string = "Salix glauca", plot_width = 10))

```

* **positive response to temperature variability (linear) and competition (sig.)**
* positive response to TRI, negative response to SRI (n.s.)

<br>


### *Vaccinium uliginosum*
```{r}
model_out.shrub_gradient.VacUli <- jags(shrub_gradient_jags.VacUli.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.VacUli) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.VacUli <- model_out.shrub_gradient.VacUli$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.VacUli),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.VacUli <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.VacUli$BUGSoutput$sims.list)-4)){
  ci_90.VacUli[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.VacUli$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.VacUli[param, 3] <- names(data.frame(model_out.shrub_gradient.VacUli$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.VacUli <- coeff.shrub_gradient.VacUli %>% 
  left_join(ci_90.VacUli, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# save(coeff.shrub_gradient.VacUli, file = file.path("..", "data", "model_outputs", "species", "outdated", "model_output_VacUli.Rdata"))
# load(file.path("..", "data", "model_outputs", "species", "outdated", "model_output_VacUli.Rdata"))

# effect size plot
(effect_size_plot.VacUli <- model_plot_marg_function(coeff.shrub_gradient.VacUli, title_string = "Vaccinium uliginosum", plot_width = 12.5))

```

* **unimodal response to temperature (sig.)**, *TWI, competition (m.s.)*
* positive response to SRI (n.s.)

<br>

As the quadratic terms for temperature variability and precipitation were not significant, they were removed from the model before re-running:
```{r}
# new model object with terms removed
write("
  
  model{

    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.shrub_cov ~ dnorm(0, 0.0001)
      b.gramin_cov ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.tcws ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      b.tempjja.x ~ dnorm(0, 0.001)
      # b.tempjja.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      
      b.tempXtcws ~ dnorm(0, 0.001)
      # b.tempXtcws2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + # ~= random effect of plot group
                        b.compet * compet.dis[i] + 
                        b.shrub_cov * shrub_cov.dis[i] + 
                        b.gramin_cov * gramin_cov.dis[i] + 
                        b.tempXtcws * tempjja.dis[i] * tcws.dis[i] +       # for interaction
                        # b.tempXtcws2 * (tempjja.dis[i]^2) * tcws.dis[i] +  # for interaction
                        b.tcws * tcws.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + # ~= random effect of plot group
                        b.compet * compet.cont[j] +
                        b.shrub_cov * shrub_cov.cont[j] +
                        b.gramin_cov * gramin_cov.cont[j] +
                        b.tempXtcws * tempjja.cont[j] * tcws.cont[j] +       # for interaction
                        # b.tempXtcws2 * (tempjja.cont[j]^2) * tcws.cont[j] +  # for interaction
                        b.tcws * tcws.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    # b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    b.tempcont.x * tempcont.tot[k] + 
                    # b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) 
      }
      
      
      # add predicted values (derived parameters)
      for (m in 1:Nxhat){
        phat_compet[m] <- intercept + b.compet * xhat_compet[m]
        phat_graminoid_cover[m] <- intercept + b.gramin_cov * xhat_graminoid_cover[m]
        phat_shrub_cover[m] <- intercept + b.shrub_cov * xhat_shrub_cover[m]
        phat_sri[m] <- intercept + b.sri * xhat_sri[m]
        phat_tri[m] <- intercept + b.tri * xhat_tri[m]
        phat_tcws[m] <- intercept + b.tcws * xhat_tcws[m]
        phat_tempjja[m] <- intercept + b.tempjja.x * xhat_tempjja[m] # + b.tempjja.x2 * (xhat_tempjja[m]^2)
        phat_tempcont[m] <- intercept + b.tempcont.x * xhat_tempcont[m] # + b.tempcont.x2 * (xhat_tempcont[m]^2)
        phat_precipjja[m] <- intercept + b.precipjja.x * xhat_precipjja[m] # + b.precipjja.x2 * (xhat_precipjja[m]^2)
      
        for (p in 1:Nxhat2){
          phat_tempXmoist[m,p] <- intercept +
                                      b.tempjja.x * xhat_tempjja[m] +
                                      # b.tempjja.x2 * (xhat_tempjja[m]^2) +
                                      b.tcws * xhat_tcws2[p] +
                                      b.tempXtcws * xhat_tempjja[m] * xhat_tcws2[p] # +
                                      # b.tempXtcws2 * (xhat_tempjja[m]^2) * xhat_tcws2[p]
          }
        }

    
      }
  ", file.path("..", "models", "shrub_gradient.VacUli2.jags"))

# specify new set of parameters to be monitored
params_VacUli2 <- c("intercept",
                    "b.tempjja.x", # "b.tempjja.x2",
                    "b.tempcont.x", # "b.tempcont.x2",
                    "b.precipjja.x", # "b.precipjja.x2",
                    "b.compet",
                    "b.shrub_cov",
                    "b.gramin_cov",
                    "b.sri",
                    "b.tri",
                    "b.tcws",
                    "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                    "sigma.plotgroup",
                    "phi",
                    "phat_compet", "phat_shrub_cover", "phat_graminoid_cover", 
                    "phat_sri", "phat_tri", "phat_tcws", 
                    "phat_tempjja", "phat_tempcont", "phat_precipjja",
                    "phat_tempXmoist")

model_out.shrub_gradient.VacUli2 <- jags(shrub_gradient_jags.VacUli.data,   # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_VacUli2,                     # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.VacUli2.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 100000, n.burnin = 70000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.VacUli2) #check convergence, etc.
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# extract coefficients 
coeff.shrub_gradient.VacUli2 <- model_out.shrub_gradient.VacUli2$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")

# add 90% CIs
ci_90.VacUli2 <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.VacUli2$BUGSoutput$sims.list)-4)){
  ci_90.VacUli2[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.VacUli2$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.VacUli2[param, 3] <- names(data.frame(model_out.shrub_gradient.VacUli2$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.VacUli2 <- coeff.shrub_gradient.VacUli2 %>% 
  left_join(ci_90.VacUli2, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

save(coeff.shrub_gradient.VacUli2, file = file.path("..", "data", "model_outputs", "model_output_VacUli2.Rdata"))

# effect size plot
(effect_size_plot.VacUli2 <- model_plot_marg_function(coeff.shrub_gradient.VacUli2, title_string = "Vaccinium uliginosum", plot_width = 10.5))

```

* **unimodal response to temperature (sig.)**, *TWI (m.s.)*
* negative response to competition, positive response to SRI (n.s.)

<br>

### > combine all plots 
```{r, eval = FALSE}
# reduced models (insig. quadratic terms removed)
model_outputs_focal_species <- file.path("..", "data", "model_outputs", list.files(path = file.path("..", "data", "model_outputs"), pattern = "*2.Rdata"))
for (model_output in model_outputs_focal_species){
  load(model_output)
}

(effect_size_plot.BetNan2 <- model_plot_marg_function(coeff.shrub_gradient.BetNan2, title_string = "Betula nana", plot_width = 10.5))
(effect_size_plot.EmpNig2 <- model_plot_marg_function(coeff.shrub_gradient.EmpNig2, title_string = "Empetrum nigrum", plot_width = 10.5))
(effect_size_plot.RhoGro2 <- model_plot_marg_function(coeff.shrub_gradient.RhoGro2, title_string = "Rhododendron groenlandicum", plot_width = 10.5))
(effect_size_plot.SalGla2 <- model_plot_marg_function(coeff.shrub_gradient.SalGla2, title_string = "Salix glauca", plot_width = 10.5))
(effect_size_plot.VacUli2 <- model_plot_marg_function(coeff.shrub_gradient.VacUli2, title_string = "Vaccinium uliginosum", plot_width = 10.5))

# 3x2 grid (vertical layout)
(nuuk_reduced_effectsize_plot_grid_ver <- plot_grid(effect_size_plot.BetNan2, 
                                            effect_size_plot.EmpNig2, 
                                            effect_size_plot.RhoGro2, 
                                            effect_size_plot.SalGla2, 
                                            effect_size_plot.VacUli2,
                                            labels = c("a)", "b)", "c)", "d)", "e)"),
                                            label_size = 20,
                                            label_fontface = "plain",
                                            hjust = -2,
                                            ncol = 2))

# save plot
# save_plot(file.path("..", "figures", "nuuk_shrub_drivers_betabinom_reduced_effect_size_panels_vert.eps"),
#           nuuk_reduced_effectsize_plot_grid_ver, base_height = 15, base_aspect_ratio = 0.8)

# # 2x3 grid (horizontal layout)
# (nuuk_reduced_effectsize_plot_grid_hor <- plot_grid(effect_size_plot.BetNan2, 
#                                             effect_size_plot.EmpNig2, 
#                                             effect_size_plot.RhoGro2, 
#                                             effect_size_plot.SalGla2, 
#                                             effect_size_plot.VacUli2,
#                                             labels = c("a)", "b)", "c)", "d)", "e)"),
#                                             label_size = 20,
#                                             label_fontface = "plain",
#                                             hjust = -2,
#                                             ncol = 3))
# 
# # save plot
# # save_plot(file.path("..", "figures", "nuuk_shrub_drivers_betabinom_reduced_effect_size_panels_hor.eps"),
# #           nuuk_reduced_effectsize_plot_grid_hor, base_height = 10, base_aspect_ratio = 1.5)

# # original models (incl all quadratic terms)
# # 3x2 grid (vertical layout)
# (nuuk_effectsize_plot_grid_ver <- plot_grid(effect_size_plot.BetNan, 
#                                             effect_size_plot.EmpNig, 
#                                             effect_size_plot.RhoGro, 
#                                             effect_size_plot.SalGla, 
#                                             effect_size_plot.VacUli,
#                                             labels = c("a)", "b)", "c)", "d)", "e)"),
#                                             label_size = 20,
#                                             label_fontface = "plain",
#                                             hjust = -2,
#                                             ncol = 2))
# 
# # save plot
# # save_plot(file.path("..", "figures", "nuuk_shrub_drivers_betabinom_effect_size_panels_vert.eps"),
# #           nuuk_effectsize_plot_grid_ver, base_height = 15, base_aspect_ratio = 0.8)
# 
# # 2x3 grid (horizontal layout)
# (nuuk_effectsize_plot_grid_hor <- plot_grid(effect_size_plot.BetNan, 
#                                             effect_size_plot.EmpNig, 
#                                             effect_size_plot.RhoGro, 
#                                             effect_size_plot.SalGla, 
#                                             effect_size_plot.VacUli,
#                                             labels = c("a)", "b)", "c)", "d)", "e)"),
#                                             label_size = 20,
#                                             label_fontface = "plain",
#                                             hjust = -2,
#                                             ncol = 3))
# 
# # save plot
# # save_plot(file.path("..", "figures", "nuuk_shrub_drivers_betabinom_effect_size_panels_hor.eps"),
# #           nuuk_effectsize_plot_grid_hor, base_height = 10, base_aspect_ratio = 1.5)
```

## Graphs
### *Betula nana* - temperature variability
```{r}

# assemble predicted and predictor values
phats <- coeff.shrub_gradient.BetNan2 %>% 
  
  # filter for predicted values
  filter(param %in% c(paste0("phat_tempcont[", seq(from = 1, to = 100), "]"))) %>% 
  
  # add xhats column
  mutate(xhats = seq(from = min(BetNan.tot$tempcontC),
                     to = max(BetNan.tot$tempcontC),
                     length.out = 100))

# back-center and back-scale predictor values (xhats)
#phats$tempcont <- phats$xhats*attr(scale(BetNan.tot$tempcont), 'scaled:scale') + attr(scale(BetNan.tot$tempcont), 'scaled:center') 
phats$tempcont <- phats$xhats*attr(scale(BetNan.tot["tempcont"]), 'scaled:scale') + attr(scale(BetNan.tot["tempcont"]), 'scaled:center') 


# GRAPH
ggplot() +
  # tempcont is modelled at plotgroup level, so reduce base data (points layer) to plotgroup level
  geom_point(data = BetNan.tot %>% group_by(site_alt_plotgroup_id) %>% summarise(tempcont = mean(tempcont), cover = mean(cover)), 
             aes(x = tempcont, 
                 y = cover), 
             size = 2,
             position = position_jitter(width=0, height=.01),
             alpha=0.5) +
  
  # draw line of predicted values
  geom_line(data = phats, 
            aes(x = tempcont, 
                y = plogis(mean)), 
            colour = "orange",
            alpha = 1,
            size = 3) + 
  
  # draw predicted 95% CI
  geom_ribbon(data = phats,
              aes(x = tempcont, 
                  ymin = plogis(l95), 
                  ymax = plogis(u95)),
              fill = "orange",
              alpha = 0.2) +
  
  # define appearance
  labs(x = "annual temperature variability [°C]",
       y = "rel. no. hits per plot") + 
  theme_bw()

# old version ---
unique.tempcont <- seq(min(BetNan.tot$tempcontC), max(BetNan.tot$tempcontC), by=0.02) 

preds.tempcont.BetNan <- array(dim=c(length(unique.tempcont), 
                                     nrow(model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list$b_plotgroup)))

for (i in 1:length(unique.tempcont)){
  preds.tempcont.BetNan[i,] <- plogis(model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list$b.tempcont.x[,1]*unique.tempcont[i] +
                                        model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list$b.tempcont.x2[,1]*(unique.tempcont[i]^2))
}

# # preds.continent1biome2 <- array(dim=c(length(unique.tempcont),
# #                                       length(model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list$b1meanForest[,1])))
# # 
# # for (i in 1:length(unique.tempcont)){
# #   preds.continent1biome2[i,] <- plogis(model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list$b1meanSavanna + model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list$brain.x[,2]*unique.tempcont[i] + model_out.shrub_gradient.BetNan2$BUGSoutput$sims.list$brain.x2[,2]*(unique.tempcont[i]^2))}


# # continentpreds <- array(c(preds.continent1biome1,preds.continent1biome2), dim=c(length(unique.tempcont), ncol(preds.continent1biome1),2))

preds.tempcont.BetNan[1:10,1:10] # [tempcont,sims]

quantiles.tempcont.BetNan <- array(NA, dim=c(length(unique.tempcont),5))


for (i in 1:length(unique.tempcont)){#tempcont
  #i<-1
    quantiles.tempcont.BetNan[i,]<-quantile(preds.tempcont.BetNan[i,], c(0.025, 0.25, 0.5, 0.95, 0.975))
}

quantiles.tempcont.BetNan[1:5,1:5]

predsmatrix.tempcont.BetNan <- data.frame(expand.grid(tempcontC=c(unique.tempcont)))
predsmatrix.tempcont.BetNan$l95CI<-rep(NA, nrow(predsmatrix.tempcont.BetNan))
predsmatrix.tempcont.BetNan$l90CI<-rep(NA, nrow(predsmatrix.tempcont.BetNan))
predsmatrix.tempcont.BetNan$med<-rep(NA, nrow(predsmatrix.tempcont.BetNan))
predsmatrix.tempcont.BetNan$u90CI<-rep(NA, nrow(predsmatrix.tempcont.BetNan))
predsmatrix.tempcont.BetNan$u95CI<-rep(NA, nrow(predsmatrix.tempcont.BetNan)) 

head(predsmatrix.tempcont.BetNan)

# # rainfallseq<-rep(1:length(unique.tempcont),each=2)

for (i in 1:nrow(predsmatrix.tempcont.BetNan)){
  predsmatrix.tempcont.BetNan[i,c(2:6)] <- quantiles.tempcont.BetNan[i,]
}

predsmatrix.tempcont.BetNan$tempcont <- attr(scale(BetNan.tot$tempcont), 'scaled:scale') + attr(scale(BetNan.tot$tempcont), 'scaled:center')

ggplot() +
  # tempcont is modelled at plotgroup level, so reduce base data (points layer) to plotgroup level
  geom_point(data = BetNan.tot %>% group_by(site_alt_plotgroup_id) %>% summarise(tempcont = mean(tempcont), cover = mean(cover)), 
             aes(x = tempcont, 
                 y = cover), 
             size = 2,
             position = position_jitter(width=0, height=.01),
             alpha=0.5) +
  
  # draw line of predicted values
  geom_line(data = predsmatrix.tempcont.BetNan, 
            aes(x = tempcont, 
                y = med), 
            colour = "orange",
            alpha = 1,
            size = 3) + 
  # scale_colour_manual(values=c("darkgreen","orange","darkgreen","orange"),name="Biome") +
  
  # draw predicted 95% CI
  geom_ribbon(data = predsmatrix.tempcont.BetNan,
                aes(x = tempcont, 
                  ymin = l95CI, 
                  ymax = u95CI),
              fill = "orange",
              alpha = 0.2) +
  
  # draw predicted 90% CI
  geom_ribbon(data = predsmatrix.tempcont.BetNan,
                aes(x = tempcont, 
                  ymin = l90CI, 
                  ymax = u90CI),
              fill = "orange",
              alpha = 0.4) +
  # scale_fill_manual(values=c("darkgreen","orange"),name="Biome") +
  labs(x = "annual temperature variability [°C]",
       y = "rel. no. hits per plot") + 
  theme_bw()
```

### *Salix glauca* - competition
```{r}

unique.compet <- seq(min(SalGla.tot$competC), max(SalGla.tot$competC), by = 0.02) 

preds.compet.SalGla <- array(dim=c(length(unique.compet), 
                                     nrow(model_out.shrub_gradient.SalGla2$BUGSoutput$sims.list$b_plotgroup)))

for (i in 1:length(unique.compet)){
  preds.compet.SalGla[i,] <- plogis(model_out.shrub_gradient.SalGla2$BUGSoutput$sims.list$b.compet[,1]*unique.compet[i])
}

# # preds.continent1biome2 <- array(dim=c(length(unique.compet), 
# #                                       length(model_out.shrub_gradient.SalGla2$BUGSoutput$sims.list$b1meanForest[,1])))
# # 
# # for (i in 1:length(unique.compet)){
# #   preds.continent1biome2[i,] <- plogis(model_out.shrub_gradient.SalGla2$BUGSoutput$sims.list$b1meanSavanna + model_out.shrub_gradient.SalGla2$BUGSoutput$sims.list$brain.x[,2]*unique.compet[i] + model_out.shrub_gradient.SalGla2$BUGSoutput$sims.list$brain.x2[,2]*(unique.compet[i]^2))}


# # continentpreds <- array(c(preds.continent1biome1,preds.continent1biome2), dim=c(length(unique.compet), ncol(preds.continent1biome1),2))

preds.compet.SalGla[1:10,1:10] # [compet,sims]

quantiles.compet.SalGla <- array(NA, dim=c(length(unique.compet),5))


for (i in 1:length(unique.compet)){#compet
  #i<-1
    quantiles.compet.SalGla[i,]<-quantile(preds.compet.SalGla[i,], c(0.025, 0.25, 0.5, 0.95, 0.975))
}

quantiles.compet.SalGla[1:5,1:5]

predsmatrix.compet.SalGla <- data.frame(expand.grid(competC=c(unique.compet)))
predsmatrix.compet.SalGla$l95CI<-rep(NA, nrow(predsmatrix.compet.SalGla))
predsmatrix.compet.SalGla$l90CI<-rep(NA, nrow(predsmatrix.compet.SalGla))
predsmatrix.compet.SalGla$med<-rep(NA, nrow(predsmatrix.compet.SalGla))
predsmatrix.compet.SalGla$u90CI<-rep(NA, nrow(predsmatrix.compet.SalGla))
predsmatrix.compet.SalGla$u95CI<-rep(NA, nrow(predsmatrix.compet.SalGla)) 

head(predsmatrix.compet.SalGla)

# # rainfallseq<-rep(1:length(unique.compet),each=2)

for (i in 1:nrow(predsmatrix.compet.SalGla)){
  predsmatrix.compet.SalGla[i,c(2:6)] <- quantiles.compet.SalGla[i,]
}

predsmatrix.compet.SalGla$compet <- predsmatrix.compet.SalGla$competC + attr(scale(SalGla.tot$compet), 'scaled:center')

(pred_plot.compet.SalGla <- ggplot() +
  # competition is modeled on plot level, so use input data as is
  geom_point(data = SalGla.tot, 
             aes(x = compet, 
                 y = cover), 
             size = 2,
             position = position_jitter(width=0, height=.01),
             alpha = 0.5) +
  
  # plot line of predicted median values
  geom_line(data = predsmatrix.compet.SalGla, 
            aes(x = compet, 
                y = med), 
            colour = "orange",
            alpha = 1,
            size = 3) + 
  # scale_colour_manual(values=c("darkgreen","orange","darkgreen","orange"),name="Biome") +
  
  # plot predicted 95% CI
  geom_ribbon(data = predsmatrix.compet.SalGla,
                aes(x = compet, 
                  ymin = l95CI, 
                  ymax = u95CI),
              fill = "orange",
              alpha = 0.2) +
  # plot predicted 90% CI
  geom_ribbon(data = predsmatrix.compet.SalGla,
                aes(x = compet, 
                  ymin = l90CI, 
                  ymax = u90CI),
              fill = "orange",
              alpha = 0.4) +
  # scale_fill_manual(values=c("darkgreen","orange"),name="Biome") +
  labs(x = "summed abundance of taller-growing species per plot",
       y = "rel. no. hits per plot") + 
  theme_bw())
```
looks weird; prediction does not relate to data points in x or y range. 


## Check predicted values

Let's run another model with some derived values to see if we get the same numbers out as the way we have extracted them above (i.e., by scaling back). That will tell us whether it's a problem with the back-scaling or a more fundamental issue.

```{r}
# assemble data: SalGla as example ----
shrub_gradient_jags.SalGla.xhat.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = SalGla.dis$cover,
  plotgroup.dis = SalGla.dis$plotgroup.NUM, #AB added this
  # isocline.dis = SalGla.dis$site_alt.NUM,
  # inclin_down.dis = SalGla.dis$inclin_downC,
  sri.dis = SalGla.dis$sriC,
  tri.dis = SalGla.dis$triC,
  twi.dis = SalGla.dis$twiC,
  compet.dis = SalGla.dis$competC,
  N_discrete = nrow(SalGla.dis),
  
  # ...and continuous part of the data
  cov.cont = SalGla.cont$cover,
  plotgroup.cont = SalGla.cont$plotgroup.NUM, #AB added this
  # isocline.cont = SalGla.cont$site_alt.NUM,
  # inclin_down.cont = SalGla.cont$inclin_downC,
  sri.cont = SalGla.cont$sriC,
  tri.cont = SalGla.cont$triC,
  twi.cont = SalGla.cont$twiC,
  compet.cont = SalGla.cont$competC,
  N_cont = nrow(SalGla.cont),
  
  # plot group level predictors
  tempjja.tot = SalGla.tot$tempjjaC[!duplicated(SalGla.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = SalGla.tot$tempmax_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)],
  # tempmin.tot = SalGla.tot$tempmin_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)],
  tempcont.tot = SalGla.tot$tempcontC[!duplicated(SalGla.tot$plotgroup.NUM)],
  precipjja.tot = SalGla.tot$precipjjaC[!duplicated(SalGla.tot$plotgroup.NUM)],
  # precipjfmam.tot = SalGla.tot$precipjfmam_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(SalGla.tot$site_alt_plotgroup_id)),
  
  xhat = seq(from = min(SalGla.tot$tempcontC), to = max(SalGla.tot$tempcontC), length.out = 100),
  Nxhat = 100
  # # site/alt level predictors
  # alt.tot = SalGla.tot$altC[!duplicated(SalGla.tot$site_alt.NUM)],
  # N_isoclines = length(unique(SalGla.tot$site_alt_id))
)
str(shrub_gradient_jags.SalGla.xhat.data)
```

We'll add some predicted values (phat) to the model:

```{r, eval = FALSE, echo = FALSE}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      # b.inclin_down ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.twi ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      # sigma.isocline ~ dunif(0,100)
      # tau.isocline <- 1/(sigma.isocline * sigma.isocline)
      # 
      # b.alt.x ~ dnorm(0, 0.001)
      # b.alt.x2 ~ dnorm(0, 0.001)
      b.tempjja.x ~ dnorm(0, 0.001)
      b.tempjja.x2 ~ dnorm(0, 0.001)
      # b.tempmax.x ~ dnorm(0, 0.001)
      # b.tempmax.x2 ~ dnorm(0, 0.001)
      # b.tempmin.x ~ dnorm(0, 0.001)
      # b.tempmin.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      # b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      # b.precipjja.x2 ~ dnorm(0, 0.001)
      # b.precipjfmam.x ~ dnorm(0, 0.001)
      # b.precipjfmam.x2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + #AB added this, ~= random effect of plot group
                        # b_isocline[isocline.dis[i]] +
                        b.compet * compet.dis[i] + 
                        # b.inclin_down * inclin_down.dis[i] +
                        b.twi * twi.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + #AB added this, ~= random effect of plot group
                        # b_isocline[isocline.cont[j]] +
                        b.compet * compet.cont[j] +
                        # b.inclin_down * inclin_down.cont[j] +
                        b.twi * twi.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    # b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    # b.tempmax.x * tempmax.tot[k] + 
                    # b.tempmax.x2 * (tempmax.tot[k]^2) +
                    # b.tempmin.x * tempmin.tot[k] + 
                    # b.tempmin.x2 * (tempmin.tot[k]^2) +
                    b.tempcont.x * tempcont.tot[k] + 
                    # b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] # + 
                    # b.precipjja.x2 * (precipjja.tot[k]^2) # +
                    # b.precipjfmam.x * precipjfmam.tot[k] + 
                    # b.precipjfmam.x2 * (precipjfmam.tot[k]^2)
      }
      
      
      # for (l in 1:N_isoclines){ #length of total isoclines
      #   b_isocline[l] ~ dnorm(mu.isocline[l],tau.isocline)
      #   mu.isocline[l] <- intercept + 
      #   
      #               # isocline-level predictor
      #               b.alt.x * alt.tot[l]
      # }

      
      # add predicted values (derived quantities)
      for (m in 1:Nxhat){
        phat[m] <- intercept + b.tempcont.x * xhat[m]
      }
    
      }
  ", file.path("..", "models", "shrub_gradient.SalGla2.xhat.jags"))
```

Specify the parameters to be monitored:
```{r, eval = FALSE, echo = FALSE}
params_SalGla2.xhat <- c("intercept",
                    # "b.alt.x",
                    "b.tempjja.x", # "b.tempjja.x2",
                    # "b.tempmax.x", "b.tempmax.x2",
                    # "b.tempmin.x", "b.tempmin.x2",
                    "b.tempcont.x", # "b.tempcont.x2",
                    "b.precipjja.x", # "b.precipjja.x2",
                    # "b.precipjfmam.x", "b.precipjfmam.x2",
                    "b.compet", 
                    # "b.inclin_down",
                    "b.sri",
                    "b.tri",
                    "b.twi",
                    "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
                    # "b_isocline[1]","b_isocline[2]","b_isocline[21]",
                    "sigma.plotgroup",
                    "phi",
                    "phat")
```

Run model:
```{r, eval = FALSE, echo = FALSE}
model_out.shrub_gradient.SalGla2.xhat <- jags(shrub_gradient_jags.SalGla.xhat.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params_SalGla2.xhat,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.SalGla2.xhat.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 10000, n.burnin = 7000,  # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

# plot(model_out.shrub_gradient.SalGla2.xhat) #check convergence, etc.

# save(model_out.shrub_gradient.SalGla2.xhat, file = file.path("..", "data", "processed", "model_output_SalGla2_with_derived_values.RData"))
```
Extract coefficients and make graph of data and prediction curve:
```{r}
# extract coefficients 
coeff.shrub_gradient.SalGla2.xhat <- model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.SalGla2.xhat),"[[]",fixed=FALSE), "[", 1))) #%>% print

# # add 90% CIs
# ci_90.SalGla2.xhat <- data.frame(q5 = NA, 
#                                  q95 = NA, 
#                                  param = NA)
# for (param in 1:(length(model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$sims.list))){
#   ci_90.SalGla2.xhat[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$sims.list[param])[,1], 
#                                             probs = c(0.05, 0.95))
#   ci_90.SalGla2.xhat[param, 3] <- names(data.frame(model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$sims.list))[param]
# }

# join to coefficients table
coeff.shrub_gradient.SalGla2.xhat <- coeff.shrub_gradient.SalGla2.xhat %>% 
  # left_join(ci_90.SalGla2.xhat, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         # l90 = q5,
         # u90 = q95,
         u95 = "97.5%",
         Rhat) # %>% print

# assemble predicted and predictor values
phats <- coeff.shrub_gradient.SalGla2.xhat %>% 
  
  # filter for predicted values
  filter(param %in% c(paste0("phat[", seq(from = 1, to = 100), "]"))) %>% 
  
  # add xhats column
  mutate(xhats = seq(from = min(SalGla.tot$tempcontC),
                     to = max(SalGla.tot$tempcontC),
                     length.out = 100))
  
# back-center and back-scale predictor values (xhats)

phats$tempcont <- phats$xhats*attr(scale(SalGla.tot$tempcont), 'scaled:scale') + attr(scale(SalGla.tot$tempcont), 'scaled:center') 

ggplot() +
  # tempcont is modelled at plotgroup level, so reduce base data (points layer) to plotgroup level
  geom_point(data = SalGla.tot %>% group_by(site_alt_plotgroup_id) %>% summarise(tempcont = mean(tempcont), cover = mean(cover)), 
             aes(x = tempcont, 
                 y = cover), 
             size = 2,
             position = position_jitter(width=0, height=.01),
             alpha=0.5) +
  
  # draw line of predicted values
  geom_line(data = phats, 
            aes(x = tempcont, 
                y = plogis(mean)), 
            colour = "orange",
            alpha = 1,
            size = 3) + 
  # scale_colour_manual(values=c("darkgreen","orange","darkgreen","orange"),name="Biome") +
  
  # draw predicted 95% CI
  geom_ribbon(data = phats,
              aes(x = tempcont, 
                  ymin = plogis(l95), 
                  ymax = plogis(u95)),
              fill = "orange",
              alpha = 0.2) +
  
  # draw predicted 90% CI
  # geom_ribbon(data = phats,
  #               aes(x = tempcont,
  #                 ymin = plogis(l90),
  #                 ymax = plogis(u90)),
  #             fill = "orange",
  #             alpha = 0.4) +
  # scale_fill_manual(values=c("darkgreen","orange"),name="Biome") +
  labs(x = "annual temperature variability [°C]",
       y = "rel. no. hits per plot") + 
  theme_bw()
```

Extract coefficients and plot effect sizes:
```{r, warning = FALSE}
# load model object
load(file = file.path("..", "data", "processed", "model_output_SalGla2_with_derived_values.RData"))
# extract coefficients 
coeff.shrub_gradient.SalGla2.xhat <- model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$summary %>% 
  as.data.frame %>% 
  select('mean','sd','2.5%','97.5%','Rhat') %>% 
# add identifying info to data frame
  rownames_to_column(var = "param")
  # mutate(param = as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.SalGla),"[[]",fixed=FALSE), "[", 1))) #%>% print

# add 90% CIs
ci_90.SalGla2.xhat <- data.frame(q5 = NA, q95 = NA, param = NA)
for (param in 1:(length(model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$sims.list)-4)){
  ci_90.SalGla2.xhat[param,1:2] <- quantile(data.frame(model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$sims.list[param])[,1], probs = c(0.05, 0.95))
  ci_90.SalGla2.xhat[param, 3] <- names(data.frame(model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$sims.list))[param]
}

# join to coefficients table
coeff.shrub_gradient.SalGla2.xhat <- coeff.shrub_gradient.SalGla2.xhat %>% 
  left_join(ci_90.SalGla2.xhat, by = "param") %>% 
  # reorder and rename cols
  select(param, mean, sd, 
         l95 = "2.5%",
         l90 = q5,
         u90 = q95,
         u95 = "97.5%",
         Rhat) %>% print

# effect size plot
(effect_size_plot.SalGla2.xhat <- model_plot_sig_function(coeff.shrub_gradient.SalGla2.xhat, title_string = "Salix glauca", plot_width = 11))

```

extract predicted values:
```{r}
# get statistical summary
model_xhat.out.df <- as.data.frame(model_out.shrub_gradient.SalGla2.xhat$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','n.eff','Rhat')])

model_xhat.out.df$Param <- sapply(strsplit(rownames(model_xhat.out.df), "[[]", fixed=F),"[",1)

p.out <- model_xhat.out.df[model_xhat.out.df$Param=="phat",]
p.out$xhat <- shrub_gradient_jags.SalGla.xhat.data$xhat #add the "x" values you used to predict phats
```

plot along with back-scaled values:
```{r}
pred_plot.compet.SalGla +
   geom_line(data = p.out, 
            aes(x = xhat, 
                y = mean), 
            colour = "darkgreen",
            alpha = 1,
            size = 2) +
  geom_ribbon(data = p.out,
              aes(x = xhat,
                  ymin = `2.5%`, 
                  ymax = `97.5%`), 
              alpha = 0.3, 
              fill = "green")
```
## ----------

## Save / load workspace image
```{r}
# save.image(file = file.path("..", "data", "processed", "nuuk_shrub_drivers_output_nonsigx2removed_graphs.RData"))

# load ws for further analyses/plotting etc)
# load(file.path("data", "processed", "nuuk_shrub_drivers_output_nonsigx2removed.RData"))
```

## ----------

## 'The Farm'

### Trial: *Betula nana*
The dataset was then ready to be split up into the species of interest. As a first trial, I focused on *Betula nana*:
```{r, eval = FALSE, echo = FALSE}
# complete Betula nana data
BetNan.tot <- filter(env_cov_bio_sub, taxon == "Betula nana")
# discrete cover values
BetNan.dis <- filter(BetNan.tot, cover_discrete == 1) # contains only zeros as responses
# continuous cover values
BetNan.cont <- filter(BetNan.tot, cover_discrete == 0)
```

### > assembling data for model input in a list

JAGS needs data input in list format, so I provided all relevant variables as follows:
```{r, eval = FALSE, echo = FALSE}
# Compile data into list ####
shrub_gradient_jags.BetNan.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = BetNan.dis$cover,
  plotgroup.dis = BetNan.dis$plotgroup.NUM, #AB added this
  # isocline.dis = BetNan.dis$site_alt.NUM,
  # inclin_down.dis = BetNan.dis$inclin_downC,
  sri.dis = BetNan.dis$sriC,
  tri.dis = BetNan.dis$triC,
  twi.dis = BetNan.dis$twiC,
  compet.dis = BetNan.dis$competC,
  N_discrete = nrow(BetNan.dis),
  
  # ...and continuous part of the data
  cov.cont = BetNan.cont$cover,
  plotgroup.cont = BetNan.cont$plotgroup.NUM, #AB added this
  # isocline.cont = BetNan.cont$site_alt.NUM,
  # inclin_down.cont = BetNan.cont$inclin_downC,
  sri.cont = BetNan.cont$sriC,
  tri.cont = BetNan.cont$triC,
  twi.cont = BetNan.cont$twiC,
  compet.cont = BetNan.cont$competC,
  N_cont = nrow(BetNan.cont),
  
  # plot group level predictors
  tempjja.tot = BetNan.tot$tempjja_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = BetNan.tot$tempmax_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  # tempmin.tot = BetNan.tot$tempmin_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  tempcont.tot = BetNan.tot$tempcont_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  precipjja.tot = BetNan.tot$precipjjaC[!duplicated(BetNan.tot$plotgroup.NUM)],
  # precipjfmam.tot = BetNan.tot$precipjfmam_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(BetNan.tot$site_alt_plotgroup_id))
  
  # # site/alt level predictors
  # alt.tot = BetNan.tot$altC[!duplicated(BetNan.tot$site_alt.NUM)],
  # N_isoclines = length(unique(BetNan.tot$site_alt_id))
)
str(shrub_gradient_jags.BetNan.data)
```

### > specifying model
```{r, eval = FALSE, echo = FALSE}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      # b.inclin_down ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.twi ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      # sigma.isocline ~ dunif(0,100)
      # tau.isocline <- 1/(sigma.isocline * sigma.isocline)
      # 
      # b.alt.x ~ dnorm(0, 0.001)
      # b.alt.x2 ~ dnorm(0, 0.001)
      b.tempjja.x ~ dnorm(0, 0.001)
      b.tempjja.x2 ~ dnorm(0, 0.001)
      # b.tempmax.x ~ dnorm(0, 0.001)
      # b.tempmax.x2 ~ dnorm(0, 0.001)
      # b.tempmin.x ~ dnorm(0, 0.001)
      # b.tempmin.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      b.precipjja.x2 ~ dnorm(0, 0.001)
      # b.precipjfmam.x ~ dnorm(0, 0.001)
      # b.precipjfmam.x2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + #AB added this, ~= random effect of plot group
                        # b_isocline[isocline.dis[i]] +
                        b.compet * compet.dis[i] + 
                        # b.inclin_down * inclin_down.dis[i] +
                        b.twi * twi.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + #AB added this, ~= random effect of plot group
                        # b_isocline[isocline.cont[j]] +
                        b.compet * compet.cont[j] +
                        # b.inclin_down * inclin_down.cont[j] +
                        b.twi * twi.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    # b.tempmax.x * tempmax.tot[k] + 
                    # b.tempmax.x2 * (tempmax.tot[k]^2) +
                    # b.tempmin.x * tempmin.tot[k] + 
                    # b.tempmin.x2 * (tempmin.tot[k]^2) +
                    b.tempcont.x * tempcont.tot[k] + 
                    b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] + 
                    b.precipjja.x2 * (precipjja.tot[k]^2) # +
                    # b.precipjfmam.x * precipjfmam.tot[k] + 
                    # b.precipjfmam.x2 * (precipjfmam.tot[k]^2)
      }
      
      
      # for (l in 1:N_isoclines){ #length of total isoclines
      #   b_isocline[l] ~ dnorm(mu.isocline[l],tau.isocline)
      #   mu.isocline[l] <- intercept + 
      #   
      #               # isocline-level predictor
      #               b.alt.x * alt.tot[l]
      # }

    
      }
  ", file.path("..", "models", "shrub_gradient.BetNan.jags"))
```

...and the parameters to be monitored:
```{r, eval = FALSE, echo = FALSE}
params <- c("intercept",
            # "b.alt.x",
            "b.tempjja.x", "b.tempjja.x2",
            # "b.tempmax.x", "b.tempmax.x2",
            # "b.tempmin.x", "b.tempmin.x2",
            "b.tempcont.x", "b.tempcont.x2",
            "b.precipjja.x", "b.precipjja.x2",
            # "b.precipjfmam.x", "b.precipjfmam.x2",
            "b.compet", 
            # "b.inclin_down", 
            "b.sri",
            "b.tri",
            "b.twi",
            "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
            "b_isocline[1]","b_isocline[2]","b_isocline[21]",
            "sigma.plotgroup","phi")
```

### > run & evaluate model
```{r, eval = FALSE, echo = FALSE}
# run model
model_out.shrub_gradient.BetNan <- jags(shrub_gradient_jags.BetNan.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.BetNan.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

plot(model_out.shrub_gradient.BetNan) #check convergence, etc.
```

Notes at first glance:

* quadratic fit better for temperature variables, linear fit better for precipitation variables
* tbc

As the model converges well, we can proceed to apply it to all of the species.
