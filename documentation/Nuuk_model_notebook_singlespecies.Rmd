---
title: 'Nuuk Fjord: Drivers of shrub abundance - beta-binomial mixture  model, separated by species'
author: "Jonathan von Oppen"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    df_print: paged
    toc: no
  html_notebook:
    code_folding: hide
    df_print: paged
    toc: no
    toc_float:
      collapsed: no
editor_options: 
  chunk_output_type: inline
---

```{r}
rm(list = ls())
```


## Dependencies
Packages included:

* tidyverse - for convenient code flow, data wrangling and plotting
* rjags & R2jags - to link JAGS and R
* skimr - for data summary
* corrr - to output correlation matrices in dataframe format
* Rmarkdown - to produce this neat little documentation
```{r setup, message = FALSE}
# load pacman package from the repository, if you do not already have it
if (!require('pacman')) install.packages('pacman', repos="https://cloud.r-project.org")
pacman::p_load(tidyverse, # set of packages for data manipulation, exploration and visualisation
               rjags,     # to link JAGS and R
               R2jags,    # to link JAGS and R
               skimr,     # for quick dataframe inspection
               corrr,     # output correlation matrices as data frame
               rmarkdown) # for R Markdown formatting
```

## Single-species models

This dataset is a new one containing predictors extracted from downscaled CHELSA climate data.

Analyses conducted on fusion table at **plot $\times$ taxon level** (as we are explicitly interested in plot-level variation of predictors, esp. slope, solar radiation, terrain ruggedness, topographical wetness, and competition): 3726 observations for 38 variables

```{r}
env_cov_bio <- read.csv("../data/nuuk_env_cover_plots.csv", header = T)
```
<!-- <button class="btn btn-primary" data-toggle="collapse" data-target="#BlockName"> Show/Hide Data Summary </button> -->
<!-- <div id="BlockName" class="collapse"> -->
<!-- ```{r} -->
<!-- skim(env_cov_bio) -->
<!-- ``` -->

### Prepare data for JAGS model 
### a) selection of variables relevant for analysis
including predictors

* Information on site, plot, plot group, sampling location (lat, lon, altitude), sampling year 
* downscaled CHELSA predictors, averaged over a 30-year period (*[...]_ts_30*) 
* solar radiation index (SRI, following [Keating et al. 2007](http://www.bioone.org/doi/abs/10.2193/2006-359)), slope (erosion measure), Terrain Ruggedness Index (TRI, following [Riley et al. 1999](http://download.osgeo.org/qgis/doc/reference-docs/Terrain_Ruggedness_Index.pdf)), Normalised Difference Wetness Index (NDWI, [Gao 1996](https://www.sciencedirect.com/science/article/pii/S0034425796000673)), Tasseled Cap Wetness Index (TCWI, [Crist & Ciccone 1984](https://ieeexplore.ieee.org/document/4157507)), SAGA Topographic Wetness Index (TWI, see [Conrad et al. 2015](https://gmd.copernicus.org/articles/8/1991/2015/) and the [index documentation](http://www.saga-gis.org/saga_tool_doc/2.2.2/ta_hydrology_15.html))
* taxon (see above for levels)
* competition pressure in the community (as summed abundance of taller-growing shrub species within a plot, averaged within plot groups)

and response variable 

* cover (as relative no. hits per plot for each species)
```{r}
env_cov_bio_sub <- env_cov_bio %>% 
  select(site_alt_plotgroup_id, plot, site, site_alt_id, year, long, lat, alt,  # plot info / metadata
  ends_with("_ts_30"),   # CHELSA predictors averaged over 10-year period prior to study year
  inclin_down, twi_90m, tri, sri, 
  #mean_summ_ndvi_yos, cv_mean_summ_ndvi_2001_to_yos, Perc_dist_coast_lines,   # environmental data
  taxon, cover, compet)   # taxon, cover response, competition pressure
head(env_cov_bio_sub)
```

Let's check for correlation between the different moisture predictors and terrain ruggedness:

```{r}
(cor_moist <- env_cov_bio %>% 
  select(twi_90m, ndwi, tcws, tri)) %>% 
  correlate(diagonal = 1)
```
$\Rightarrow$ NDWI and TCWS are highly correlated, but both are largely independent from TWI and TRI.
We'll go with TWI for now, as it is least confounded by vegetation, but will have to discuss maybe including a second index, depending on hypothesis/ecological implication.

<br>

Predictors don't always vary between plots within plotgroups - perhaps due to several falling into the same CHELSA grid cell.

Example: plots within site 1, altitude 20, plot group 1: plot P146 is slightly off and therefore has different climate variables than the other ones

```{r}
env_cov_bio %>% filter(taxon == "Betula nana" & site_alt_plotgroup_id == "1_20_1") %>% 
  ggplot(aes(x = long, y = lat)) + 
  geom_point() + 
  geom_text(aes(label = plot), hjust = 0.0001) + 
  xlim(c(-51.78675, -51.7863))
env_cov_bio %>% filter(taxon == "Betula nana" & site_alt_plotgroup_id == "1_20_1") %>% 
  select(site_alt_plotgroup_id, plot, tempjja_ts_30)
```

Check for correlation between predictors:

```{r}
predictors_set <- env_cov_bio_sub %>% 
  select(ends_with("_ts_30"),   # CHELSA predictors averaged over 10-year period prior to study year
         inclin_down, twi_90m, tri, sri,    # environmental data
         compet, alt) %>% 
  names()
# create basic correlation matrix
(cor_mat <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set) %>% 
  correlate(diagonal = 1) %>% 
  # drop all values < .4 to increase readability
  mutate_if(is.numeric, ~ ifelse(abs(.) < .4, NA, .)))
```

$\Rightarrow$ Maximum temperature is highly correlated with JJA temperature, minimum temperature with continentality, slope (inclin_down) with solar radiation, and spring precipitation variables with JJA precipitation.
Let's exclude them step by step and check the variance inflation factors (VIF) along the way. VIF values > 10 indicate collinearity issues.

```{r}
# for the whole set of predictors
(vif_predictors_1 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set) %>% 
  usdm::vif()) #%>% View()
# => drop tempmax (correlated w/ tempjja)
(vif_predictors_2 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30) %>% 
  usdm::vif()) #%>% View()
# => drop tempmin (correlated w/ tempcont)
(vif_predictors_3 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30,
                -tempmin_ts_30) %>% 
  usdm::vif()) #%>% View()
# => drop precipjfmam (correlated w/ precipjja & tempcont)
(vif_predictors_4 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30,
                -tempmin_ts_30,
                -contains("jfm")) %>% 
  usdm::vif()) #%>% View()
# => drop inclin_down (correlated w/ SRI)
(vif_predictors_5 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30,
                -tempmin_ts_30,
                -inclin_down,
                -contains("jfm")) %>% 
  usdm::vif()) #%>% View()
(vif_predictors_6 <- env_cov_bio_sub %>% 
  dplyr::select(predictors_set,
                -tempmax_ts_30,
                -tempmin_ts_30,
                -inclin_down,
                -contains("mam")) %>% 
  usdm::vif()) #%>% View()
```

All VIF are now < 3.1 -> OK! We can now exclude the dropped variables to obtain the final dataset:

```{r}
env_cov_bio_sub <- env_cov_bio_sub %>% 
  dplyr::select(-tempmax_ts_30,
                -tempmin_ts_30,
                -inclin_down,
                -contains("mam"))
```


### b) adjustion of data structure

Data was ordered by site/altitude/plotgroup and taxon
```{r}
env_cov_bio_sub <- env_cov_bio_sub[order(env_cov_bio_sub$site_alt_plotgroup_id, env_cov_bio_sub$taxon),]

```

As JAGS is only able to handle numeric input, all variables are assigned a numeric identifier:
```{r}
env_cov_bio_sub$plotgroup.NUM <- as.numeric(factor(env_cov_bio_sub$site_alt_plotgroup_id,
                                                   levels = unique(env_cov_bio_sub$site_alt_plotgroup_id)))
env_cov_bio_sub$plot.NUM <- as.numeric(factor(env_cov_bio_sub$plot,
                                              levels = unique(env_cov_bio_sub$plot)))
env_cov_bio_sub$site_alt.NUM <- as.numeric(factor(env_cov_bio_sub$site_alt_id,
                                              levels = unique(env_cov_bio_sub$site_alt_id)))
env_cov_bio_sub$site.NUM <- as.numeric(factor(env_cov_bio_sub$site, levels = unique(env_cov_bio_sub$site)))
env_cov_bio_sub$taxon.NUM <- as.numeric(factor(env_cov_bio_sub$taxon, levels = unique(env_cov_bio_sub$taxon)))
```

Taxa were coded as follows: 
```{r}
data.frame(taxon = levels(env_cov_bio_sub$taxon),
           num = unique(env_cov_bio_sub$taxon.NUM))
```

Numeric predictors were scaled: 
```{r}
num_pred <- env_cov_bio_sub %>% select(alt,
                                       ends_with("_ts_30"), 
                                       sri, 
                                       tri,
                                       starts_with("twi"), 
                                       matches("compet"))
for(i in 1:length(num_pred)){
  col <- colnames(num_pred[i])
  env_cov_bio_sub[paste0(col,"C")] <- as.numeric(scale(num_pred[i], scale = TRUE, center = TRUE))
}
```

To account for the range of the cover response ($0 \leq cover \leq 1$), the model needs a mixed structure incorporating a beta distribution (for all continuous values with $0 < cover < 1$) and a binomial distribution (for all discrete values of $cover = \{0, 1\}$). An additional variable *cover_discrete* was introduced to separate the dataset into discrete (= 1) and continuous (= 0) cover values:
```{r}
env_cov_bio_sub$cover_discrete <- ifelse(env_cov_bio_sub$cover == 1 | env_cov_bio_sub$cover == 0, 1, 0)
```

### Betula nana
The dataset was then ready to be split up into the species of interest. As a first trial, I focused on *Betula nana*:
```{r}
# complete Betula nana data
BetNan.tot <- filter(env_cov_bio_sub, taxon == "Betula nana")
# discrete cover values
BetNan.dis <- filter(BetNan.tot, cover_discrete == 1) # contains only zeros as responses
# continuous cover values
BetNan.cont <- filter(BetNan.tot, cover_discrete == 0)
```

### > assembling data for model input in a list

JAGS needs data input in list format, so I provided all relevant variables as follows:
```{r}
# Compile data into list ####
shrub_gradient_jags.BetNan.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = BetNan.dis$cover,
  plotgroup.dis = BetNan.dis$plotgroup.NUM, #AB added this
  isocline.dis = BetNan.dis$site_alt.NUM,
  # inclin_down.dis = BetNan.dis$inclin_downC,
  sri.dis = BetNan.dis$sriC,
  tri.dis = BetNan.dis$triC,
  twi_90m.dis = BetNan.dis$twi_90mC,
  compet.dis = BetNan.dis$competC,
  N_discrete = nrow(BetNan.dis),
  
  # ...and continuous part of the data
  cov.cont = BetNan.cont$cover,
  plotgroup.cont = BetNan.cont$plotgroup.NUM, #AB added this
  isocline.cont = BetNan.cont$site_alt.NUM,
  # inclin_down.cont = BetNan.cont$inclin_downC,
  sri.cont = BetNan.cont$sriC,
  tri.cont = BetNan.cont$triC,
  twi_90m.cont = BetNan.cont$twi_90mC,
  compet.cont = BetNan.cont$competC,
  N_cont = nrow(BetNan.cont),
  
  # plot group level predictors
  tempjja.tot = BetNan.tot$tempjja_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = BetNan.tot$tempmax_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  # tempmin.tot = BetNan.tot$tempmin_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  tempcont.tot = BetNan.tot$tempcont_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  precipjja.tot = BetNan.tot$precipjja_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  # precipjfmam.tot = BetNan.tot$precipjfmam_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(BetNan.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = BetNan.tot$altC[!duplicated(BetNan.tot$site_alt.NUM)],
  N_isoclines = length(unique(BetNan.tot$site_alt_id))
)
str(shrub_gradient_jags.BetNan.data)
```

### > specifying model
```{r}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      # b.inclin_down ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.twi_90m ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      sigma.isocline ~ dunif(0,100)
      tau.isocline <- 1/(sigma.isocline * sigma.isocline)
      
      b.alt.x ~ dnorm(0, 0.001)
      b.alt.x2 ~ dnorm(0, 0.001)
      b.tempjja.x ~ dnorm(0, 0.001)
      b.tempjja.x2 ~ dnorm(0, 0.001)
      # b.tempmax.x ~ dnorm(0, 0.001)
      # b.tempmax.x2 ~ dnorm(0, 0.001)
      # b.tempmin.x ~ dnorm(0, 0.001)
      # b.tempmin.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      b.precipjja.x2 ~ dnorm(0, 0.001)
      # b.precipjfmam.x ~ dnorm(0, 0.001)
      # b.precipjfmam.x2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + #AB added this, ~= random effect of plot group
                        b_isocline[isocline.dis[i]] +
                        b.compet * compet.dis[i] + 
                        # b.inclin_down * inclin_down.dis[i] +
                        b.twi_90m * twi_90m.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + #AB added this, ~= random effect of plot group
                        b_isocline[isocline.cont[j]] +
                        b.compet * compet.cont[j] +
                        # b.inclin_down * inclin_down.cont[j] +
                        b.twi_90m * twi_90m.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    # b.tempmax.x * tempmax.tot[k] + 
                    # b.tempmax.x2 * (tempmax.tot[k]^2) +
                    # b.tempmin.x * tempmin.tot[k] + 
                    # b.tempmin.x2 * (tempmin.tot[k]^2) +
                    b.tempcont.x * tempcont.tot[k] + 
                    b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] + 
                    b.precipjja.x2 * (precipjja.tot[k]^2) # +
                    # b.precipjfmam.x * precipjfmam.tot[k] + 
                    # b.precipjfmam.x2 * (precipjfmam.tot[k]^2)
      }
      
      
      for (l in 1:N_isoclines){ #length of total isoclines
        b_isocline[l] ~ dnorm(mu.isocline[l],tau.isocline)
        mu.isocline[l] <- intercept + 
        
                    # isocline-level predictor
                    b.alt.x * alt.tot[l]
      }

    
      }
  ", file.path("..", "models", "shrub_gradient.BetNan.jags"))
```

...and the parameters to be monitored:
```{r}
params <- c("intercept",
            "b.alt.x",
            "b.tempjja.x", "b.tempjja.x2",
            # "b.tempmax.x", "b.tempmax.x2",
            # "b.tempmin.x", "b.tempmin.x2",
            "b.tempcont.x", "b.tempcont.x2",
            "b.precipjja.x", "b.precipjja.x2",
            # "b.precipjfmam.x", "b.precipjfmam.x2",
            "b.compet", 
            # "b.inclin_down", 
            "b.sri",
            "b.tri",
            "b.twi_90m",
            "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
            "b_isocline[1]","b_isocline[2]","b_isocline[21]",
            "sigma.plotgroup","phi")
```

### > run & evaluate model
```{r}
# run model
model_out.shrub_gradient.BetNan <- jags(shrub_gradient_jags.BetNan.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.BetNan.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

plot(model_out.shrub_gradient.BetNan) #check convergence, etc.
```

Notes at first glance:

* quadratic fit better for temperature variables, linear fit better for precipitation variables
* tbc

As the model converges well, we can proceed to apply it to all of the species.

<br>

### All species
The dataset was then ready to be split up into the species of interest. We create separate data subsets for all/discrete/continuous response variable values for each species:
```{r}
# split dataframe by taxon
env_cov_bio_sub_spec.tot <- split(env_cov_bio_sub, env_cov_bio_sub$taxon)

# assign taxon name to list elements
# >> for total datasets
for (taxon_id in 1:nlevels(env_cov_bio_sub$taxon)){
  # extract 3-letter genus name string
  assign(paste0(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id], 
                            "^\\w{3}"),
  # extract and capitalise 3-letter species name string
                str_to_title(str_remove(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id],
                                                    "\\s\\w{3}"),
                                        "\\s")),
  # add extension
                ".tot"),
  # assign to respective list element
         env_cov_bio_sub_spec.tot[[taxon_id]])
}



# >> for discrete datasets
env_cov_bio_sub_spec.dis <- list()
for (taxon_id in 1:nlevels(env_cov_bio_sub$taxon)){
  # filter for discrete response values
  env_cov_bio_sub_spec.dis[[taxon_id]] <- filter(env_cov_bio_sub_spec.tot[[taxon_id]], cover_discrete == 1)
  # extract 3-letter genus name string
  assign(paste0(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id], 
                            "^\\w{3}"),
  # extract and capitalise 3-letter species name string
                str_to_title(str_remove(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id],
                                                    "\\s\\w{3}"),
                                        "\\s")),
  # add extension
                ".dis"),
  # assign to respective list element
         env_cov_bio_sub_spec.dis[[taxon_id]])
}

# >> for continuous datasets
env_cov_bio_sub_spec.cont <- list()
for (taxon_id in 1:nlevels(env_cov_bio_sub$taxon)){
  # filter for continuous response values
  env_cov_bio_sub_spec.cont[[taxon_id]] <- filter(env_cov_bio_sub_spec.tot[[taxon_id]], cover_discrete == 0)
  # extract 3-letter genus name string
  assign(paste0(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id], 
                            "^\\w{3}"),
  # extract and capitalise 3-letter species name string
                str_to_title(str_remove(str_extract(levels(env_cov_bio_sub$taxon)[taxon_id],
                                                    "\\s\\w{3}"),
                                        "\\s")),
  # add extension
                ".cont"),
  # assign to respective list element
         env_cov_bio_sub_spec.cont[[taxon_id]])
}

```

### > assembling data for model input in lists

JAGS needs data input in list format, so I provided all relevant variables as follows:
```{r}
# data_list_abbrev <- c()
# extensions <- rep(c(".tot", ".dis", ".cont"), nlevels(env_cov_bio_sub$taxon))
# for (dataset_id in 1:length(extensions)){
#     
#     # extract 3-letter genus name string
#     data_list_abbrev[dataset_id] <- paste0(str_extract(levels(env_cov_bio_sub$taxon)[ceiling(dataset_id/3)], 
#                                                       "^\\w{3}"),
#     # extract and capitalise 3-letter species name string
#     str_to_title(str_remove(str_extract(levels(env_cov_bio_sub$taxon)[ceiling(dataset_id/3)],
#                                         "\\s\\w{3}"),
#                             "\\s")),
#   # add extensions
#     extensions[dataset_id])
# }
# 
# taxon_list_abbrev <- paste0(str_extract(levels(env_cov_bio_sub$taxon),
#                                         "^\\w{3}"),
#                             str_to_title(str_remove(str_extract(levels(env_cov_bio_sub$taxon),
#                                                                 "\\s\\w{3}"),
#                                                     "\\s")))

# Compile data into lists
# BetNan ----
shrub_gradient_jags.BetNan.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = BetNan.dis$cover,
  plotgroup.dis = BetNan.dis$plotgroup.NUM, #AB added this
  isocline.dis = BetNan.dis$site_alt.NUM,
  # inclin_down.dis = BetNan.dis$inclin_downC,
  sri.dis = BetNan.dis$sriC,
  tri.dis = BetNan.dis$triC,
  twi_90m.dis = BetNan.dis$twi_90mC,
  compet.dis = BetNan.dis$competC,
  N_discrete = nrow(BetNan.dis),
  
  # ...and continuous part of the data
  cov.cont = BetNan.cont$cover,
  plotgroup.cont = BetNan.cont$plotgroup.NUM, #AB added this
  isocline.cont = BetNan.cont$site_alt.NUM,
  # inclin_down.cont = BetNan.cont$inclin_downC,
  sri.cont = BetNan.cont$sriC,
  tri.cont = BetNan.cont$triC,
  twi_90m.cont = BetNan.cont$twi_90mC,
  compet.cont = BetNan.cont$competC,
  N_cont = nrow(BetNan.cont),
  
  # plot group level predictors
  tempjja.tot = BetNan.tot$tempjja_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = BetNan.tot$tempmax_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  # tempmin.tot = BetNan.tot$tempmin_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  tempcont.tot = BetNan.tot$tempcont_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  precipjja.tot = BetNan.tot$precipjja_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)],
  # precipjfmam.tot = BetNan.tot$precipjfmam_ts_30C[!duplicated(BetNan.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(BetNan.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = BetNan.tot$altC[!duplicated(BetNan.tot$site_alt.NUM)],
  N_isoclines = length(unique(BetNan.tot$site_alt_id))
)
str(shrub_gradient_jags.BetNan.data)

# CasTet ----
shrub_gradient_jags.CasTet.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = CasTet.dis$cover,
  plotgroup.dis = CasTet.dis$plotgroup.NUM, #AB added this
  isocline.dis = CasTet.dis$site_alt.NUM,
  # inclin_down.dis = CasTet.dis$inclin_downC,
  sri.dis = CasTet.dis$sriC,
  tri.dis = CasTet.dis$triC,
  twi_90m.dis = CasTet.dis$twi_90mC,
  compet.dis = CasTet.dis$competC,
  N_discrete = nrow(CasTet.dis),
  
  # ...and continuous part of the data
  cov.cont = CasTet.cont$cover,
  plotgroup.cont = CasTet.cont$plotgroup.NUM, #AB added this
  isocline.cont = CasTet.cont$site_alt.NUM,
  # inclin_down.cont = CasTet.cont$inclin_downC,
  sri.cont = CasTet.cont$sriC,
  tri.cont = CasTet.cont$triC,
  twi_90m.cont = CasTet.cont$twi_90mC,
  compet.cont = CasTet.cont$competC,
  N_cont = nrow(CasTet.cont),
  
  # plot group level predictors
  tempjja.tot = CasTet.tot$tempjja_ts_30C[!duplicated(CasTet.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = CasTet.tot$tempmax_ts_30C[!duplicated(CasTet.tot$plotgroup.NUM)],
  # tempmin.tot = CasTet.tot$tempmin_ts_30C[!duplicated(CasTet.tot$plotgroup.NUM)],
  tempcont.tot = CasTet.tot$tempcont_ts_30C[!duplicated(CasTet.tot$plotgroup.NUM)],
  precipjja.tot = CasTet.tot$precipjja_ts_30C[!duplicated(CasTet.tot$plotgroup.NUM)],
  # precipjfmam.tot = CasTet.tot$precipjfmam_ts_30C[!duplicated(CasTet.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(CasTet.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = CasTet.tot$altC[!duplicated(CasTet.tot$site_alt.NUM)],
  N_isoclines = length(unique(CasTet.tot$site_alt_id))
)
str(shrub_gradient_jags.CasTet.data)

# EmpNig ----
shrub_gradient_jags.EmpNig.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = EmpNig.dis$cover,
  plotgroup.dis = EmpNig.dis$plotgroup.NUM, #AB added this
  isocline.dis = EmpNig.dis$site_alt.NUM,
  # inclin_down.dis = EmpNig.dis$inclin_downC,
  sri.dis = EmpNig.dis$sriC,
  tri.dis = EmpNig.dis$triC,
  twi_90m.dis = EmpNig.dis$twi_90mC,
  compet.dis = EmpNig.dis$competC,
  N_discrete = nrow(EmpNig.dis),
  
  # ...and continuous part of the data
  cov.cont = EmpNig.cont$cover,
  plotgroup.cont = EmpNig.cont$plotgroup.NUM, #AB added this
  isocline.cont = EmpNig.cont$site_alt.NUM,
  # inclin_down.cont = EmpNig.cont$inclin_downC,
  sri.cont = EmpNig.cont$sriC,
  tri.cont = EmpNig.cont$triC,
  twi_90m.cont = EmpNig.cont$twi_90mC,
  compet.cont = EmpNig.cont$competC,
  N_cont = nrow(EmpNig.cont),
  
  # plot group level predictors
  tempjja.tot = EmpNig.tot$tempjja_ts_30C[!duplicated(EmpNig.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = EmpNig.tot$tempmax_ts_30C[!duplicated(EmpNig.tot$plotgroup.NUM)],
  # tempmin.tot = EmpNig.tot$tempmin_ts_30C[!duplicated(EmpNig.tot$plotgroup.NUM)],
  tempcont.tot = EmpNig.tot$tempcont_ts_30C[!duplicated(EmpNig.tot$plotgroup.NUM)],
  precipjja.tot = EmpNig.tot$precipjja_ts_30C[!duplicated(EmpNig.tot$plotgroup.NUM)],
  # precipjfmam.tot = EmpNig.tot$precipjfmam_ts_30C[!duplicated(EmpNig.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(EmpNig.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = EmpNig.tot$altC[!duplicated(EmpNig.tot$site_alt.NUM)],
  N_isoclines = length(unique(EmpNig.tot$site_alt_id))
)
str(shrub_gradient_jags.EmpNig.data)

# PhyCae ----
shrub_gradient_jags.PhyCae.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = PhyCae.dis$cover,
  plotgroup.dis = PhyCae.dis$plotgroup.NUM, #AB added this
  isocline.dis = PhyCae.dis$site_alt.NUM,
  # inclin_down.dis = PhyCae.dis$inclin_downC,
  sri.dis = PhyCae.dis$sriC,
  tri.dis = PhyCae.dis$triC,
  twi_90m.dis = PhyCae.dis$twi_90mC,
  compet.dis = PhyCae.dis$competC,
  N_discrete = nrow(PhyCae.dis),
  
  # ...and continuous part of the data
  cov.cont = PhyCae.cont$cover,
  plotgroup.cont = PhyCae.cont$plotgroup.NUM, #AB added this
  isocline.cont = PhyCae.cont$site_alt.NUM,
  # inclin_down.cont = PhyCae.cont$inclin_downC,
  sri.cont = PhyCae.cont$sriC,
  tri.cont = PhyCae.cont$triC,
  twi_90m.cont = PhyCae.cont$twi_90mC,
  compet.cont = PhyCae.cont$competC,
  N_cont = nrow(PhyCae.cont),
  
  # plot group level predictors
  tempjja.tot = PhyCae.tot$tempjja_ts_30C[!duplicated(PhyCae.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = PhyCae.tot$tempmax_ts_30C[!duplicated(PhyCae.tot$plotgroup.NUM)],
  # tempmin.tot = PhyCae.tot$tempmin_ts_30C[!duplicated(PhyCae.tot$plotgroup.NUM)],
  tempcont.tot = PhyCae.tot$tempcont_ts_30C[!duplicated(PhyCae.tot$plotgroup.NUM)],
  precipjja.tot = PhyCae.tot$precipjja_ts_30C[!duplicated(PhyCae.tot$plotgroup.NUM)],
  # precipjfmam.tot = PhyCae.tot$precipjfmam_ts_30C[!duplicated(PhyCae.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(PhyCae.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = PhyCae.tot$altC[!duplicated(PhyCae.tot$site_alt.NUM)],
  N_isoclines = length(unique(PhyCae.tot$site_alt_id))
)
str(shrub_gradient_jags.PhyCae.data)

# RhoGro ----
shrub_gradient_jags.RhoGro.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = RhoGro.dis$cover,
  plotgroup.dis = RhoGro.dis$plotgroup.NUM, #AB added this
  isocline.dis = RhoGro.dis$site_alt.NUM,
  # inclin_down.dis = RhoGro.dis$inclin_downC,
  sri.dis = RhoGro.dis$sriC,
  tri.dis = RhoGro.dis$triC,
  twi_90m.dis = RhoGro.dis$twi_90mC,
  compet.dis = RhoGro.dis$competC,
  N_discrete = nrow(RhoGro.dis),
  
  # ...and continuous part of the data
  cov.cont = RhoGro.cont$cover,
  plotgroup.cont = RhoGro.cont$plotgroup.NUM, #AB added this
  isocline.cont = RhoGro.cont$site_alt.NUM,
  # inclin_down.cont = RhoGro.cont$inclin_downC,
  sri.cont = RhoGro.cont$sriC,
  tri.cont = RhoGro.cont$triC,
  twi_90m.cont = RhoGro.cont$twi_90mC,
  compet.cont = RhoGro.cont$competC,
  N_cont = nrow(RhoGro.cont),
  
  # plot group level predictors
  tempjja.tot = RhoGro.tot$tempjja_ts_30C[!duplicated(RhoGro.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = RhoGro.tot$tempmax_ts_30C[!duplicated(RhoGro.tot$plotgroup.NUM)],
  # tempmin.tot = RhoGro.tot$tempmin_ts_30C[!duplicated(RhoGro.tot$plotgroup.NUM)],
  tempcont.tot = RhoGro.tot$tempcont_ts_30C[!duplicated(RhoGro.tot$plotgroup.NUM)],
  precipjja.tot = RhoGro.tot$precipjja_ts_30C[!duplicated(RhoGro.tot$plotgroup.NUM)],
  # precipjfmam.tot = RhoGro.tot$precipjfmam_ts_30C[!duplicated(RhoGro.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(RhoGro.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = RhoGro.tot$altC[!duplicated(RhoGro.tot$site_alt.NUM)],
  N_isoclines = length(unique(RhoGro.tot$site_alt_id))
)
str(shrub_gradient_jags.RhoGro.data)

# RhoTom ----
shrub_gradient_jags.RhoTom.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = RhoTom.dis$cover,
  plotgroup.dis = RhoTom.dis$plotgroup.NUM, #AB added this
  isocline.dis = RhoTom.dis$site_alt.NUM,
  # inclin_down.dis = RhoTom.dis$inclin_downC,
  sri.dis = RhoTom.dis$sriC,
  tri.dis = RhoTom.dis$triC,
  twi_90m.dis = RhoTom.dis$twi_90mC,
  compet.dis = RhoTom.dis$competC,
  N_discrete = nrow(RhoTom.dis),
  
  # ...and continuous part of the data
  cov.cont = RhoTom.cont$cover,
  plotgroup.cont = RhoTom.cont$plotgroup.NUM, #AB added this
  isocline.cont = RhoTom.cont$site_alt.NUM,
  # inclin_down.cont = RhoTom.cont$inclin_downC,
  sri.cont = RhoTom.cont$sriC,
  tri.cont = RhoTom.cont$triC,
  twi_90m.cont = RhoTom.cont$twi_90mC,
  compet.cont = RhoTom.cont$competC,
  N_cont = nrow(RhoTom.cont),
  
  # plot group level predictors
  tempjja.tot = RhoTom.tot$tempjja_ts_30C[!duplicated(RhoTom.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = RhoTom.tot$tempmax_ts_30C[!duplicated(RhoTom.tot$plotgroup.NUM)],
  # tempmin.tot = RhoTom.tot$tempmin_ts_30C[!duplicated(RhoTom.tot$plotgroup.NUM)],
  tempcont.tot = RhoTom.tot$tempcont_ts_30C[!duplicated(RhoTom.tot$plotgroup.NUM)],
  precipjja.tot = RhoTom.tot$precipjja_ts_30C[!duplicated(RhoTom.tot$plotgroup.NUM)],
  # precipjfmam.tot = RhoTom.tot$precipjfmam_ts_30C[!duplicated(RhoTom.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(RhoTom.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = RhoTom.tot$altC[!duplicated(RhoTom.tot$site_alt.NUM)],
  N_isoclines = length(unique(RhoTom.tot$site_alt_id))
)
str(shrub_gradient_jags.RhoTom.data)

# SalArc ----
shrub_gradient_jags.SalArc.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = SalArc.dis$cover,
  plotgroup.dis = SalArc.dis$plotgroup.NUM, #AB added this
  isocline.dis = SalArc.dis$site_alt.NUM,
  # inclin_down.dis = SalArc.dis$inclin_downC,
  sri.dis = SalArc.dis$sriC,
  tri.dis = SalArc.dis$triC,
  twi_90m.dis = SalArc.dis$twi_90mC,
  compet.dis = SalArc.dis$competC,
  N_discrete = nrow(SalArc.dis),
  
  # ...and continuous part of the data
  cov.cont = SalArc.cont$cover,
  plotgroup.cont = SalArc.cont$plotgroup.NUM, #AB added this
  isocline.cont = SalArc.cont$site_alt.NUM,
  # inclin_down.cont = SalArc.cont$inclin_downC,
  sri.cont = SalArc.cont$sriC,
  tri.cont = SalArc.cont$triC,
  twi_90m.cont = SalArc.cont$twi_90mC,
  compet.cont = SalArc.cont$competC,
  N_cont = nrow(SalArc.cont),
  
  # plot group level predictors
  tempjja.tot = SalArc.tot$tempjja_ts_30C[!duplicated(SalArc.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = SalArc.tot$tempmax_ts_30C[!duplicated(SalArc.tot$plotgroup.NUM)],
  # tempmin.tot = SalArc.tot$tempmin_ts_30C[!duplicated(SalArc.tot$plotgroup.NUM)],
  tempcont.tot = SalArc.tot$tempcont_ts_30C[!duplicated(SalArc.tot$plotgroup.NUM)],
  precipjja.tot = SalArc.tot$precipjja_ts_30C[!duplicated(SalArc.tot$plotgroup.NUM)],
  # precipjfmam.tot = SalArc.tot$precipjfmam_ts_30C[!duplicated(SalArc.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(SalArc.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = SalArc.tot$altC[!duplicated(SalArc.tot$site_alt.NUM)],
  N_isoclines = length(unique(SalArc.tot$site_alt_id))
)
str(shrub_gradient_jags.SalArc.data)

# SalGla ----
shrub_gradient_jags.SalGla.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = SalGla.dis$cover,
  plotgroup.dis = SalGla.dis$plotgroup.NUM, #AB added this
  isocline.dis = SalGla.dis$site_alt.NUM,
  # inclin_down.dis = SalGla.dis$inclin_downC,
  sri.dis = SalGla.dis$sriC,
  tri.dis = SalGla.dis$triC,
  twi_90m.dis = SalGla.dis$twi_90mC,
  compet.dis = SalGla.dis$competC,
  N_discrete = nrow(SalGla.dis),
  
  # ...and continuous part of the data
  cov.cont = SalGla.cont$cover,
  plotgroup.cont = SalGla.cont$plotgroup.NUM, #AB added this
  isocline.cont = SalGla.cont$site_alt.NUM,
  # inclin_down.cont = SalGla.cont$inclin_downC,
  sri.cont = SalGla.cont$sriC,
  tri.cont = SalGla.cont$triC,
  twi_90m.cont = SalGla.cont$twi_90mC,
  compet.cont = SalGla.cont$competC,
  N_cont = nrow(SalGla.cont),
  
  # plot group level predictors
  tempjja.tot = SalGla.tot$tempjja_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = SalGla.tot$tempmax_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)],
  # tempmin.tot = SalGla.tot$tempmin_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)],
  tempcont.tot = SalGla.tot$tempcont_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)],
  precipjja.tot = SalGla.tot$precipjja_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)],
  # precipjfmam.tot = SalGla.tot$precipjfmam_ts_30C[!duplicated(SalGla.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(SalGla.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = SalGla.tot$altC[!duplicated(SalGla.tot$site_alt.NUM)],
  N_isoclines = length(unique(SalGla.tot$site_alt_id))
)
str(shrub_gradient_jags.SalGla.data)

# VacUli ----
shrub_gradient_jags.VacUli.data <- list(
  
  # plot level predictors, for discrete...
  cov.dis = VacUli.dis$cover,
  plotgroup.dis = VacUli.dis$plotgroup.NUM, #AB added this
  isocline.dis = VacUli.dis$site_alt.NUM,
  # inclin_down.dis = VacUli.dis$inclin_downC,
  sri.dis = VacUli.dis$sriC,
  tri.dis = VacUli.dis$triC,
  twi_90m.dis = VacUli.dis$twi_90mC,
  compet.dis = VacUli.dis$competC,
  N_discrete = nrow(VacUli.dis),
  
  # ...and continuous part of the data
  cov.cont = VacUli.cont$cover,
  plotgroup.cont = VacUli.cont$plotgroup.NUM, #AB added this
  isocline.cont = VacUli.cont$site_alt.NUM,
  # inclin_down.cont = VacUli.cont$inclin_downC,
  sri.cont = VacUli.cont$sriC,
  tri.cont = VacUli.cont$triC,
  twi_90m.cont = VacUli.cont$twi_90mC,
  compet.cont = VacUli.cont$competC,
  N_cont = nrow(VacUli.cont),
  
  # plot group level predictors
  tempjja.tot = VacUli.tot$tempjja_ts_30C[!duplicated(VacUli.tot$plotgroup.NUM)], # one value per tXpg
  # tempmax.tot = VacUli.tot$tempmax_ts_30C[!duplicated(VacUli.tot$plotgroup.NUM)],
  # tempmin.tot = VacUli.tot$tempmin_ts_30C[!duplicated(VacUli.tot$plotgroup.NUM)],
  tempcont.tot = VacUli.tot$tempcont_ts_30C[!duplicated(VacUli.tot$plotgroup.NUM)],
  precipjja.tot = VacUli.tot$precipjja_ts_30C[!duplicated(VacUli.tot$plotgroup.NUM)],
  # precipjfmam.tot = VacUli.tot$precipjfmam_ts_30C[!duplicated(VacUli.tot$plotgroup.NUM)]
  N_plotgroups = length(unique(VacUli.tot$site_alt_plotgroup_id)),
  
  # site/alt level predictors
  alt.tot = VacUli.tot$altC[!duplicated(VacUli.tot$site_alt.NUM)],
  N_isoclines = length(unique(VacUli.tot$site_alt_id))
)
str(shrub_gradient_jags.VacUli.data)


```

### > specifying model
```{r}
write("
  
  model{
    
    # priors
      
      intercept ~ dnorm(0, 0.0001)
      
      b.compet ~ dnorm(0, 0.0001)
      b.sri ~ dnorm(0, 0.0001)
      # b.inclin_down ~ dnorm(0, 0.0001)
      b.tri ~ dnorm(0, 0.0001)
      b.twi_90m ~ dnorm(0, 0.0001)

      sigma.plotgroup ~ dunif(0,100)
      tau.plotgroup <- 1/(sigma.plotgroup * sigma.plotgroup)
      
      sigma.isocline ~ dunif(0,100)
      tau.isocline <- 1/(sigma.isocline * sigma.isocline)
      
      b.alt.x ~ dnorm(0, 0.001)
      b.alt.x2 ~ dnorm(0, 0.001)
      b.tempjja.x ~ dnorm(0, 0.001)
      b.tempjja.x2 ~ dnorm(0, 0.001)
      # b.tempmax.x ~ dnorm(0, 0.001)
      # b.tempmax.x2 ~ dnorm(0, 0.001)
      # b.tempmin.x ~ dnorm(0, 0.001)
      # b.tempmin.x2 ~ dnorm(0, 0.001)
      b.tempcont.x ~ dnorm(0, 0.001)
      b.tempcont.x2 ~ dnorm(0, 0.001)
      b.precipjja.x ~ dnorm(0, 0.001)
      b.precipjja.x2 ~ dnorm(0, 0.001)
      # b.precipjfmam.x ~ dnorm(0, 0.001)
      # b.precipjfmam.x2 ~ dnorm(0, 0.001)
      
      phi ~ dgamma(0.1, 0.1)
      
      
    # LIKELIHOOD for discrete part

      for (i in 1:N_discrete){ 
        cov.dis[i] ~ dbern(mu[i])
        logit(mu[i]) <- b_plotgroup[plotgroup.dis[i]] + #AB added this, ~= random effect of plot group
                        b_isocline[isocline.dis[i]] +
                        b.compet * compet.dis[i] + 
                        # b.inclin_down * inclin_down.dis[i] +
                        b.twi_90m * twi_90m.dis[i] + 
                        b.sri * sri.dis[i] +
                        b.tri * tri.dis[i]
      }
      
      
    # LIKELIHOOD for continuous part

      for (j in 1:N_cont){
        cov.cont[j] ~ dbeta(p[j], q[j])
        p[j] <- mu2[j] * phi
        q[j] <- (1 - mu2[j]) * phi
        logit(mu2[j]) <- b_plotgroup[plotgroup.cont[j]] + #AB added this, ~= random effect of plot group
                        b_isocline[isocline.cont[j]] +
                        b.compet * compet.cont[j] +
                        # b.inclin_down * inclin_down.cont[j] +
                        b.twi_90m * twi_90m.cont[j] + 
                        b.sri * sri.cont[j] +
                        b.tri * tri.cont[j]
      }


      for (k in 1:N_plotgroups){ # length of total plotgroups
        b_plotgroup[k] ~ dnorm(mu.plotgroup[k],tau.plotgroup)
        mu.plotgroup[k] <- intercept + 
                    
                    # plot group level predictors, linear and quadratic term
                    b.tempjja.x * tempjja.tot[k] + 
                    b.tempjja.x2 * (tempjja.tot[k]^2) + 
                    # b.tempmax.x * tempmax.tot[k] + 
                    # b.tempmax.x2 * (tempmax.tot[k]^2) +
                    # b.tempmin.x * tempmin.tot[k] + 
                    # b.tempmin.x2 * (tempmin.tot[k]^2) +
                    b.tempcont.x * tempcont.tot[k] + 
                    b.tempcont.x2 * (tempcont.tot[k]^2) +
                    b.precipjja.x * precipjja.tot[k] + 
                    b.precipjja.x2 * (precipjja.tot[k]^2) # +
                    # b.precipjfmam.x * precipjfmam.tot[k] + 
                    # b.precipjfmam.x2 * (precipjfmam.tot[k]^2)
      }
      
      
      for (l in 1:N_isoclines){ #length of total isoclines
        b_isocline[l] ~ dnorm(mu.isocline[l],tau.isocline)
        mu.isocline[l] <- intercept + 
        
                    # isocline-level predictor
                    b.alt.x * alt.tot[l]
      }

    
      }
  ", file.path("..", "models", "shrub_gradient.spec.jags"))
```

Specify the parameters to be monitored:
```{r}
params <- c("intercept",
            "b.alt.x",
            "b.tempjja.x", "b.tempjja.x2",
            # "b.tempmax.x", "b.tempmax.x2",
            # "b.tempmin.x", "b.tempmin.x2",
            "b.tempcont.x", "b.tempcont.x2",
            "b.precipjja.x", "b.precipjja.x2",
            # "b.precipjfmam.x", "b.precipjfmam.x2",
            "b.compet", 
            # "b.inclin_down", 
            "b.sri",
            "b.tri",
            "b.twi_90m",
            "b_plotgroup[1]","b_plotgroup[2]","b_plotgroup[3]","b_plotgroup[63]",
            "b_isocline[1]","b_isocline[2]","b_isocline[21]",
            "sigma.plotgroup","phi")
```

### > run & evaluate model
```{r}
# run model
model_out.shrub_gradient.BetNan <- jags(shrub_gradient_jags.BetNan.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text") 

plot(model_out.shrub_gradient.BetNan) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.BetNan<-as.data.frame(model_out.shrub_gradient.BetNan$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.BetNan$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.BetNan),"[[]",fixed=FALSE), "[", 1))
```

* negative response to competition, precipitation, temperature variation
* no significant response to other variables

```{r}
model_out.shrub_gradient.CasTet <- jags(shrub_gradient_jags.CasTet.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

plot(model_out.shrub_gradient.CasTet) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.CasTet<-as.data.frame(model_out.shrub_gradient.CasTet$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.CasTet$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.CasTet),"[[]",fixed=FALSE), "[", 1))
```

* **not converging**: really large R-hat values (only 16 non-zero values)


```{r}
model_out.shrub_gradient.EmpNig <- jags(shrub_gradient_jags.EmpNig.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

plot(model_out.shrub_gradient.EmpNig) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.EmpNig<-as.data.frame(model_out.shrub_gradient.EmpNig$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.EmpNig$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.EmpNig),"[[]",fixed=FALSE), "[", 1))
```

* positive response to precipitation (linear)
* marginally significant positive repsonse to competition, SRI and TWI
* negative response to temperature (quadratic)

```{r}
model_out.shrub_gradient.PhyCae <- jags(shrub_gradient_jags.PhyCae.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

plot(model_out.shrub_gradient.PhyCae) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.PhyCae<-as.data.frame(model_out.shrub_gradient.PhyCae$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.PhyCae$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.PhyCae),"[[]",fixed=FALSE), "[", 1))
```

* negative response to SRI, temp variation (quadratic)
* marginally significant positive response to precipitation
* less clearly converged (only 10 non-zero values)

```{r}
model_out.shrub_gradient.RhoGro <- jags(shrub_gradient_jags.RhoGro.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

plot(model_out.shrub_gradient.RhoGro) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.RhoGro<-as.data.frame(model_out.shrub_gradient.RhoGro$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.RhoGro$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.RhoGro),"[[]",fixed=FALSE), "[", 1))
```

* negative response to precipitation (linear), temperature (quadratic)
* marginally significant positive response to SRI, temp. variation
* marginally significant negative responst to TWI


```{r}
model_out.shrub_gradient.RhoTom <- jags(shrub_gradient_jags.RhoTom.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

plot(model_out.shrub_gradient.RhoTom) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.RhoTom<-as.data.frame(model_out.shrub_gradient.RhoTom$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.RhoTom$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.RhoTom),"[[]",fixed=FALSE), "[", 1))
```

* **not converging well**: relatively large R-hat values, large variation in parameter estimates (only 13 non-zero values)


```{r}
model_out.shrub_gradient.SalArc <- jags(shrub_gradient_jags.SalArc.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

plot(model_out.shrub_gradient.SalArc) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.SalArc<-as.data.frame(model_out.shrub_gradient.SalArc$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.SalArc$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.SalArc),"[[]",fixed=FALSE), "[", 1))
```

* **not converging well**: relatively large R-hat values, quite some variation in parameter estimates (only 13 non-zero values)


```{r}
model_out.shrub_gradient.SalGla <- jags(shrub_gradient_jags.SalGla.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

plot(model_out.shrub_gradient.SalGla) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.SalGla<-as.data.frame(model_out.shrub_gradient.SalGla$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.SalGla$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.SalGla),"[[]",fixed=FALSE), "[", 1))
```

* positive response to competition
* marginally significant positive response to temperature (linear)
* negative response to SRI


```{r}
model_out.shrub_gradient.VacUli <- jags(shrub_gradient_jags.VacUli.data,    # input data
                                        inits = NULL,                       # JAGS to create initial values
                                        params,                             # parameters to be saved
                                        model.file = file.path("..", "models", "shrub_gradient.spec.jags"), 
                                        n.chains = 3,                       # no. Markov chains
                                        n.iter = 8000, n.burnin = 6000,     # no. iterations & burn-in fraction per chain
                                        n.thin = 2,                         # thinning rate
                                        DIC = FALSE,                        # do not compute deviance, pD, and DIC
                                        working.directory = NULL, 
                                        progress.bar = "text")

plot(model_out.shrub_gradient.VacUli) #check convergence, etc.

# extract coefficients 
coeff.shrub_gradient.VacUli<-as.data.frame(model_out.shrub_gradient.VacUli$BUGSoutput$summary[,c('mean','sd','2.5%','97.5%','Rhat')])
# add identifying info to data frame
coeff.shrub_gradient.VacUli$param <- as.vector(sapply(strsplit(rownames(coeff.shrub_gradient.VacUli),"[[]",fixed=FALSE), "[", 1))
```

* negative response to competition, temperature (quadratic) & TWI
* positive response to SRI
